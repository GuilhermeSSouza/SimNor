Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> funcs
Rule 2     prog -> externs funcs
Rule 3     externs -> extern
Rule 4     externs -> extern externs
Rule 5     funcs -> func
Rule 6     funcs -> func funcs
Rule 7     extern -> EXTERN TYPE GLOBID LParen RParen Semicolon
Rule 8     extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon
Rule 9     func -> DEF TYPE GLOBID LParen RParen blk
Rule 10    func -> DEF TYPE GLOBID LParen vdecls RParen blk
Rule 11    blk -> LBracket stmts RBracket
Rule 12    blk -> LBracket RBracket
Rule 13    stmts -> stmt
Rule 14    stmts -> stmt stmts
Rule 15    stmt -> blk
Rule 16    stmt -> Return Semicolon
Rule 17    stmt -> Return exp Semicolon
Rule 18    stmt -> vdecl Equal exp Semicolon
Rule 19    stmt -> exp Semicolon
Rule 20    stmt -> While LParen exp RParen stmt
Rule 21    stmt -> If LParen exp RParen stmt
Rule 22    stmt -> If LParen exp RParen stmt Else stmt
Rule 23    stmt -> Print exp Semicolon
Rule 24    stmt -> Array LSquare lit RSquare
Rule 25    exps -> exp
Rule 26    exps -> exp COMMA exps
Rule 27    exp -> LParen exp RParen
Rule 28    exp -> lit
Rule 29    exp -> binop
Rule 30    exp -> GLOBID
Rule 31    exp -> GLOBID expWrapper
Rule 32    expWrapper -> LParen RParen
Rule 33    expWrapper -> LParen exps RParen
Rule 34    binop -> exp Multiply exp
Rule 35    binop -> exp PLUS exp
Rule 36    binop -> exp Divide exp
Rule 37    binop -> exp Minus exp
Rule 38    binop -> GLOBID Equal exp
Rule 39    binop -> exp Equality exp
Rule 40    binop -> exp Different exp
Rule 41    vdecls -> vdecl COMMA vdecls
Rule 42    vdecls -> vdecl
Rule 43    vdecl -> TYPE GLOBID
Rule 44    tdecls -> TYPE
Rule 45    tdecls -> TYPE COMMA tdecls
Rule 46    TYPE -> int
Rule 47    TYPE -> void
Rule 48    TYPE -> ref TYPE
Rule 49    TYPE -> noalias ref TYPE

Terminals, with rules where they appear

Array                : 24
COMMA                : 26 41 45
DEF                  : 9 10
Different            : 40
Divide               : 36
EXTERN               : 7 8
Else                 : 22
Equal                : 18 38
Equality             : 39
GLOBID               : 7 8 9 10 30 31 38 43
If                   : 21 22
LBracket             : 11 12
LParen               : 7 8 9 10 20 21 22 27 32 33
LSquare              : 24
Minus                : 37
Multiply             : 34
PLUS                 : 35
Print                : 23
RBracket             : 11 12
RParen               : 7 8 9 10 20 21 22 27 32 33
RSquare              : 24
Return               : 16 17
Semicolon            : 7 8 16 17 18 19 23
While                : 20
error                : 
int                  : 46
lit                  : 24 28
noalias              : 49
ref                  : 48 49
void                 : 47

Nonterminals, with rules where they appear

TYPE                 : 7 8 9 10 43 44 45 48 49
binop                : 29
blk                  : 9 10 15
exp                  : 17 18 19 20 21 22 23 25 26 27 34 34 35 35 36 36 37 37 38 39 39 40 40
expWrapper           : 31
exps                 : 26 33
extern               : 3 4
externs              : 2 4
func                 : 5 6
funcs                : 1 2 6
prog                 : 0
stmt                 : 13 14 20 21 22 22
stmts                : 11 14
tdecls               : 8 45
vdecl                : 18 41 42
vdecls               : 10 41

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . funcs
    (2) prog -> . externs funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             shift and go to state 6
    EXTERN          shift and go to state 7

    prog                           shift and go to state 1
    funcs                          shift and go to state 2
    externs                        shift and go to state 3
    func                           shift and go to state 4
    extern                         shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> funcs .

    $end            reduce using rule 1 (prog -> funcs .)


state 3

    (2) prog -> externs . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    DEF             shift and go to state 6

    funcs                          shift and go to state 8
    func                           shift and go to state 4

state 4

    (5) funcs -> func .
    (6) funcs -> func . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    $end            reduce using rule 5 (funcs -> func .)
    DEF             shift and go to state 6

    func                           shift and go to state 4
    funcs                          shift and go to state 9

state 5

    (3) externs -> extern .
    (4) externs -> extern . externs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             reduce using rule 3 (externs -> extern .)
    EXTERN          shift and go to state 7

    extern                         shift and go to state 5
    externs                        shift and go to state 10

state 6

    (9) func -> DEF . TYPE GLOBID LParen RParen blk
    (10) func -> DEF . TYPE GLOBID LParen vdecls RParen blk
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 11

state 7

    (7) extern -> EXTERN . TYPE GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN . TYPE GLOBID LParen tdecls RParen Semicolon
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 16

state 8

    (2) prog -> externs funcs .

    $end            reduce using rule 2 (prog -> externs funcs .)


state 9

    (6) funcs -> func funcs .

    $end            reduce using rule 6 (funcs -> func funcs .)


state 10

    (4) externs -> extern externs .

    DEF             reduce using rule 4 (externs -> extern externs .)


state 11

    (9) func -> DEF TYPE . GLOBID LParen RParen blk
    (10) func -> DEF TYPE . GLOBID LParen vdecls RParen blk

    GLOBID          shift and go to state 17


state 12

    (46) TYPE -> int .

    GLOBID          reduce using rule 46 (TYPE -> int .)
    COMMA           reduce using rule 46 (TYPE -> int .)
    RParen          reduce using rule 46 (TYPE -> int .)


state 13

    (47) TYPE -> void .

    GLOBID          reduce using rule 47 (TYPE -> void .)
    COMMA           reduce using rule 47 (TYPE -> void .)
    RParen          reduce using rule 47 (TYPE -> void .)


state 14

    (48) TYPE -> ref . TYPE
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 18

state 15

    (49) TYPE -> noalias . ref TYPE

    ref             shift and go to state 19


state 16

    (7) extern -> EXTERN TYPE . GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN TYPE . GLOBID LParen tdecls RParen Semicolon

    GLOBID          shift and go to state 20


state 17

    (9) func -> DEF TYPE GLOBID . LParen RParen blk
    (10) func -> DEF TYPE GLOBID . LParen vdecls RParen blk

    LParen          shift and go to state 21


state 18

    (48) TYPE -> ref TYPE .

    GLOBID          reduce using rule 48 (TYPE -> ref TYPE .)
    COMMA           reduce using rule 48 (TYPE -> ref TYPE .)
    RParen          reduce using rule 48 (TYPE -> ref TYPE .)


state 19

    (49) TYPE -> noalias ref . TYPE
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 22

state 20

    (7) extern -> EXTERN TYPE GLOBID . LParen RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID . LParen tdecls RParen Semicolon

    LParen          shift and go to state 23


state 21

    (9) func -> DEF TYPE GLOBID LParen . RParen blk
    (10) func -> DEF TYPE GLOBID LParen . vdecls RParen blk
    (41) vdecls -> . vdecl COMMA vdecls
    (42) vdecls -> . vdecl
    (43) vdecl -> . TYPE GLOBID
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 25
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 24
    vdecls                         shift and go to state 26
    vdecl                          shift and go to state 27

state 22

    (49) TYPE -> noalias ref TYPE .

    GLOBID          reduce using rule 49 (TYPE -> noalias ref TYPE .)
    COMMA           reduce using rule 49 (TYPE -> noalias ref TYPE .)
    RParen          reduce using rule 49 (TYPE -> noalias ref TYPE .)


state 23

    (7) extern -> EXTERN TYPE GLOBID LParen . RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID LParen . tdecls RParen Semicolon
    (44) tdecls -> . TYPE
    (45) tdecls -> . TYPE COMMA tdecls
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 29
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 28
    tdecls                         shift and go to state 30

state 24

    (43) vdecl -> TYPE . GLOBID

    GLOBID          shift and go to state 31


state 25

    (9) func -> DEF TYPE GLOBID LParen RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 33

    blk                            shift and go to state 32

state 26

    (10) func -> DEF TYPE GLOBID LParen vdecls . RParen blk

    RParen          shift and go to state 34


state 27

    (41) vdecls -> vdecl . COMMA vdecls
    (42) vdecls -> vdecl .

    COMMA           shift and go to state 35
    RParen          reduce using rule 42 (vdecls -> vdecl .)


state 28

    (44) tdecls -> TYPE .
    (45) tdecls -> TYPE . COMMA tdecls

    RParen          reduce using rule 44 (tdecls -> TYPE .)
    COMMA           shift and go to state 36


state 29

    (7) extern -> EXTERN TYPE GLOBID LParen RParen . Semicolon

    Semicolon       shift and go to state 37


state 30

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls . RParen Semicolon

    RParen          shift and go to state 38


state 31

    (43) vdecl -> TYPE GLOBID .

    COMMA           reduce using rule 43 (vdecl -> TYPE GLOBID .)
    RParen          reduce using rule 43 (vdecl -> TYPE GLOBID .)
    Equal           reduce using rule 43 (vdecl -> TYPE GLOBID .)


state 32

    (9) func -> DEF TYPE GLOBID LParen RParen blk .

    DEF             reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)
    $end            reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)


state 33

    (11) blk -> LBracket . stmts RBracket
    (12) blk -> LBracket . RBracket
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (43) vdecl -> . TYPE GLOBID
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    RBracket        shift and go to state 40
    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    stmts                          shift and go to state 39
    stmt                           shift and go to state 41
    blk                            shift and go to state 42
    exp                            shift and go to state 44
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 34

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 33

    blk                            shift and go to state 54

state 35

    (41) vdecls -> vdecl COMMA . vdecls
    (41) vdecls -> . vdecl COMMA vdecls
    (42) vdecls -> . vdecl
    (43) vdecl -> . TYPE GLOBID
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    vdecl                          shift and go to state 27
    vdecls                         shift and go to state 55
    TYPE                           shift and go to state 24

state 36

    (45) tdecls -> TYPE COMMA . tdecls
    (44) tdecls -> . TYPE
    (45) tdecls -> . TYPE COMMA tdecls
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 28
    tdecls                         shift and go to state 56

state 37

    (7) extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .

    EXTERN          reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)
    DEF             reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)


state 38

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen . Semicolon

    Semicolon       shift and go to state 57


state 39

    (11) blk -> LBracket stmts . RBracket

    RBracket        shift and go to state 58


state 40

    (12) blk -> LBracket RBracket .

    DEF             reduce using rule 12 (blk -> LBracket RBracket .)
    $end            reduce using rule 12 (blk -> LBracket RBracket .)
    Return          reduce using rule 12 (blk -> LBracket RBracket .)
    While           reduce using rule 12 (blk -> LBracket RBracket .)
    If              reduce using rule 12 (blk -> LBracket RBracket .)
    Print           reduce using rule 12 (blk -> LBracket RBracket .)
    Array           reduce using rule 12 (blk -> LBracket RBracket .)
    LBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    LParen          reduce using rule 12 (blk -> LBracket RBracket .)
    lit             reduce using rule 12 (blk -> LBracket RBracket .)
    GLOBID          reduce using rule 12 (blk -> LBracket RBracket .)
    int             reduce using rule 12 (blk -> LBracket RBracket .)
    void            reduce using rule 12 (blk -> LBracket RBracket .)
    ref             reduce using rule 12 (blk -> LBracket RBracket .)
    noalias         reduce using rule 12 (blk -> LBracket RBracket .)
    RBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    Else            reduce using rule 12 (blk -> LBracket RBracket .)


state 41

    (13) stmts -> stmt .
    (14) stmts -> stmt . stmts
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (43) vdecl -> . TYPE GLOBID
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    RBracket        reduce using rule 13 (stmts -> stmt .)
    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    stmt                           shift and go to state 41
    stmts                          shift and go to state 59
    blk                            shift and go to state 42
    exp                            shift and go to state 44
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 42

    (15) stmt -> blk .

    Return          reduce using rule 15 (stmt -> blk .)
    While           reduce using rule 15 (stmt -> blk .)
    If              reduce using rule 15 (stmt -> blk .)
    Print           reduce using rule 15 (stmt -> blk .)
    Array           reduce using rule 15 (stmt -> blk .)
    LBracket        reduce using rule 15 (stmt -> blk .)
    LParen          reduce using rule 15 (stmt -> blk .)
    lit             reduce using rule 15 (stmt -> blk .)
    GLOBID          reduce using rule 15 (stmt -> blk .)
    int             reduce using rule 15 (stmt -> blk .)
    void            reduce using rule 15 (stmt -> blk .)
    ref             reduce using rule 15 (stmt -> blk .)
    noalias         reduce using rule 15 (stmt -> blk .)
    RBracket        reduce using rule 15 (stmt -> blk .)
    Else            reduce using rule 15 (stmt -> blk .)


state 43

    (16) stmt -> Return . Semicolon
    (17) stmt -> Return . exp Semicolon
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    Semicolon       shift and go to state 60
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 61
    binop                          shift and go to state 53

state 44

    (19) stmt -> exp . Semicolon
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       shift and go to state 62
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 45

    (18) stmt -> vdecl . Equal exp Semicolon

    Equal           shift and go to state 69


state 46

    (20) stmt -> While . LParen exp RParen stmt

    LParen          shift and go to state 70


state 47

    (27) exp -> LParen . exp RParen
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 71
    binop                          shift and go to state 53

state 48

    (21) stmt -> If . LParen exp RParen stmt
    (22) stmt -> If . LParen exp RParen stmt Else stmt

    LParen          shift and go to state 72


state 49

    (23) stmt -> Print . exp Semicolon
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 73
    binop                          shift and go to state 53

state 50

    (24) stmt -> Array . LSquare lit RSquare

    LSquare         shift and go to state 74


state 51

    (28) exp -> lit .

    Semicolon       reduce using rule 28 (exp -> lit .)
    Multiply        reduce using rule 28 (exp -> lit .)
    PLUS            reduce using rule 28 (exp -> lit .)
    Divide          reduce using rule 28 (exp -> lit .)
    Minus           reduce using rule 28 (exp -> lit .)
    Equality        reduce using rule 28 (exp -> lit .)
    Different       reduce using rule 28 (exp -> lit .)
    RParen          reduce using rule 28 (exp -> lit .)
    COMMA           reduce using rule 28 (exp -> lit .)


state 52

    (30) exp -> GLOBID .
    (31) exp -> GLOBID . expWrapper
    (38) binop -> GLOBID . Equal exp
    (32) expWrapper -> . LParen RParen
    (33) expWrapper -> . LParen exps RParen

    Semicolon       reduce using rule 30 (exp -> GLOBID .)
    Multiply        reduce using rule 30 (exp -> GLOBID .)
    PLUS            reduce using rule 30 (exp -> GLOBID .)
    Divide          reduce using rule 30 (exp -> GLOBID .)
    Minus           reduce using rule 30 (exp -> GLOBID .)
    Equality        reduce using rule 30 (exp -> GLOBID .)
    Different       reduce using rule 30 (exp -> GLOBID .)
    RParen          reduce using rule 30 (exp -> GLOBID .)
    COMMA           reduce using rule 30 (exp -> GLOBID .)
    Equal           shift and go to state 76
    LParen          shift and go to state 77

    expWrapper                     shift and go to state 75

state 53

    (29) exp -> binop .

    Semicolon       reduce using rule 29 (exp -> binop .)
    Multiply        reduce using rule 29 (exp -> binop .)
    PLUS            reduce using rule 29 (exp -> binop .)
    Divide          reduce using rule 29 (exp -> binop .)
    Minus           reduce using rule 29 (exp -> binop .)
    Equality        reduce using rule 29 (exp -> binop .)
    Different       reduce using rule 29 (exp -> binop .)
    RParen          reduce using rule 29 (exp -> binop .)
    COMMA           reduce using rule 29 (exp -> binop .)


state 54

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen blk .

    DEF             reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)
    $end            reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)


state 55

    (41) vdecls -> vdecl COMMA vdecls .

    RParen          reduce using rule 41 (vdecls -> vdecl COMMA vdecls .)


state 56

    (45) tdecls -> TYPE COMMA tdecls .

    RParen          reduce using rule 45 (tdecls -> TYPE COMMA tdecls .)


state 57

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .

    EXTERN          reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)
    DEF             reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)


state 58

    (11) blk -> LBracket stmts RBracket .

    DEF             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    $end            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Return          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    While           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    If              reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Print           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Array           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LParen          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    lit             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    GLOBID          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    int             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    void            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    ref             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    noalias         reduce using rule 11 (blk -> LBracket stmts RBracket .)
    RBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Else            reduce using rule 11 (blk -> LBracket stmts RBracket .)


state 59

    (14) stmts -> stmt stmts .

    RBracket        reduce using rule 14 (stmts -> stmt stmts .)


state 60

    (16) stmt -> Return Semicolon .

    Return          reduce using rule 16 (stmt -> Return Semicolon .)
    While           reduce using rule 16 (stmt -> Return Semicolon .)
    If              reduce using rule 16 (stmt -> Return Semicolon .)
    Print           reduce using rule 16 (stmt -> Return Semicolon .)
    Array           reduce using rule 16 (stmt -> Return Semicolon .)
    LBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    LParen          reduce using rule 16 (stmt -> Return Semicolon .)
    lit             reduce using rule 16 (stmt -> Return Semicolon .)
    GLOBID          reduce using rule 16 (stmt -> Return Semicolon .)
    int             reduce using rule 16 (stmt -> Return Semicolon .)
    void            reduce using rule 16 (stmt -> Return Semicolon .)
    ref             reduce using rule 16 (stmt -> Return Semicolon .)
    noalias         reduce using rule 16 (stmt -> Return Semicolon .)
    RBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    Else            reduce using rule 16 (stmt -> Return Semicolon .)


state 61

    (17) stmt -> Return exp . Semicolon
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       shift and go to state 78
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 62

    (19) stmt -> exp Semicolon .

    Return          reduce using rule 19 (stmt -> exp Semicolon .)
    While           reduce using rule 19 (stmt -> exp Semicolon .)
    If              reduce using rule 19 (stmt -> exp Semicolon .)
    Print           reduce using rule 19 (stmt -> exp Semicolon .)
    Array           reduce using rule 19 (stmt -> exp Semicolon .)
    LBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    LParen          reduce using rule 19 (stmt -> exp Semicolon .)
    lit             reduce using rule 19 (stmt -> exp Semicolon .)
    GLOBID          reduce using rule 19 (stmt -> exp Semicolon .)
    int             reduce using rule 19 (stmt -> exp Semicolon .)
    void            reduce using rule 19 (stmt -> exp Semicolon .)
    ref             reduce using rule 19 (stmt -> exp Semicolon .)
    noalias         reduce using rule 19 (stmt -> exp Semicolon .)
    RBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    Else            reduce using rule 19 (stmt -> exp Semicolon .)


state 63

    (34) binop -> exp Multiply . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 79
    binop                          shift and go to state 53

state 64

    (35) binop -> exp PLUS . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 80
    binop                          shift and go to state 53

state 65

    (36) binop -> exp Divide . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 81
    binop                          shift and go to state 53

state 66

    (37) binop -> exp Minus . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 82
    binop                          shift and go to state 53

state 67

    (39) binop -> exp Equality . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 83
    binop                          shift and go to state 53

state 68

    (40) binop -> exp Different . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 84
    binop                          shift and go to state 53

state 69

    (18) stmt -> vdecl Equal . exp Semicolon
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 85
    binop                          shift and go to state 53

state 70

    (20) stmt -> While LParen . exp RParen stmt
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 86
    binop                          shift and go to state 53

state 71

    (27) exp -> LParen exp . RParen
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    RParen          shift and go to state 87
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 72

    (21) stmt -> If LParen . exp RParen stmt
    (22) stmt -> If LParen . exp RParen stmt Else stmt
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 88
    binop                          shift and go to state 53

state 73

    (23) stmt -> Print exp . Semicolon
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       shift and go to state 89
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 74

    (24) stmt -> Array LSquare . lit RSquare

    lit             shift and go to state 90


state 75

    (31) exp -> GLOBID expWrapper .

    Semicolon       reduce using rule 31 (exp -> GLOBID expWrapper .)
    Multiply        reduce using rule 31 (exp -> GLOBID expWrapper .)
    PLUS            reduce using rule 31 (exp -> GLOBID expWrapper .)
    Divide          reduce using rule 31 (exp -> GLOBID expWrapper .)
    Minus           reduce using rule 31 (exp -> GLOBID expWrapper .)
    Equality        reduce using rule 31 (exp -> GLOBID expWrapper .)
    Different       reduce using rule 31 (exp -> GLOBID expWrapper .)
    RParen          reduce using rule 31 (exp -> GLOBID expWrapper .)
    COMMA           reduce using rule 31 (exp -> GLOBID expWrapper .)


state 76

    (38) binop -> GLOBID Equal . exp
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 91
    binop                          shift and go to state 53

state 77

    (32) expWrapper -> LParen . RParen
    (33) expWrapper -> LParen . exps RParen
    (25) exps -> . exp
    (26) exps -> . exp COMMA exps
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    RParen          shift and go to state 92
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exps                           shift and go to state 93
    exp                            shift and go to state 94
    binop                          shift and go to state 53

state 78

    (17) stmt -> Return exp Semicolon .

    Return          reduce using rule 17 (stmt -> Return exp Semicolon .)
    While           reduce using rule 17 (stmt -> Return exp Semicolon .)
    If              reduce using rule 17 (stmt -> Return exp Semicolon .)
    Print           reduce using rule 17 (stmt -> Return exp Semicolon .)
    Array           reduce using rule 17 (stmt -> Return exp Semicolon .)
    LBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    LParen          reduce using rule 17 (stmt -> Return exp Semicolon .)
    lit             reduce using rule 17 (stmt -> Return exp Semicolon .)
    GLOBID          reduce using rule 17 (stmt -> Return exp Semicolon .)
    int             reduce using rule 17 (stmt -> Return exp Semicolon .)
    void            reduce using rule 17 (stmt -> Return exp Semicolon .)
    ref             reduce using rule 17 (stmt -> Return exp Semicolon .)
    noalias         reduce using rule 17 (stmt -> Return exp Semicolon .)
    RBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    Else            reduce using rule 17 (stmt -> Return exp Semicolon .)


state 79

    (34) binop -> exp Multiply exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 34 (binop -> exp Multiply exp .)
    Multiply        reduce using rule 34 (binop -> exp Multiply exp .)
    PLUS            reduce using rule 34 (binop -> exp Multiply exp .)
    Divide          reduce using rule 34 (binop -> exp Multiply exp .)
    Minus           reduce using rule 34 (binop -> exp Multiply exp .)
    Equality        reduce using rule 34 (binop -> exp Multiply exp .)
    Different       reduce using rule 34 (binop -> exp Multiply exp .)
    RParen          reduce using rule 34 (binop -> exp Multiply exp .)
    COMMA           reduce using rule 34 (binop -> exp Multiply exp .)

  ! Multiply        [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! Divide          [ shift and go to state 65 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 80

    (35) binop -> exp PLUS exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 35 (binop -> exp PLUS exp .)
    PLUS            reduce using rule 35 (binop -> exp PLUS exp .)
    Minus           reduce using rule 35 (binop -> exp PLUS exp .)
    Equality        reduce using rule 35 (binop -> exp PLUS exp .)
    Different       reduce using rule 35 (binop -> exp PLUS exp .)
    RParen          reduce using rule 35 (binop -> exp PLUS exp .)
    COMMA           reduce using rule 35 (binop -> exp PLUS exp .)
    Multiply        shift and go to state 63
    Divide          shift and go to state 65

  ! Multiply        [ reduce using rule 35 (binop -> exp PLUS exp .) ]
  ! Divide          [ reduce using rule 35 (binop -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 81

    (36) binop -> exp Divide exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 36 (binop -> exp Divide exp .)
    Multiply        reduce using rule 36 (binop -> exp Divide exp .)
    PLUS            reduce using rule 36 (binop -> exp Divide exp .)
    Divide          reduce using rule 36 (binop -> exp Divide exp .)
    Minus           reduce using rule 36 (binop -> exp Divide exp .)
    Equality        reduce using rule 36 (binop -> exp Divide exp .)
    Different       reduce using rule 36 (binop -> exp Divide exp .)
    RParen          reduce using rule 36 (binop -> exp Divide exp .)
    COMMA           reduce using rule 36 (binop -> exp Divide exp .)

  ! Multiply        [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! Divide          [ shift and go to state 65 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 82

    (37) binop -> exp Minus exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 37 (binop -> exp Minus exp .)
    PLUS            reduce using rule 37 (binop -> exp Minus exp .)
    Minus           reduce using rule 37 (binop -> exp Minus exp .)
    Equality        reduce using rule 37 (binop -> exp Minus exp .)
    Different       reduce using rule 37 (binop -> exp Minus exp .)
    RParen          reduce using rule 37 (binop -> exp Minus exp .)
    COMMA           reduce using rule 37 (binop -> exp Minus exp .)
    Multiply        shift and go to state 63
    Divide          shift and go to state 65

  ! Multiply        [ reduce using rule 37 (binop -> exp Minus exp .) ]
  ! Divide          [ reduce using rule 37 (binop -> exp Minus exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 83

    (39) binop -> exp Equality exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 39 (binop -> exp Equality exp .)
    Equality        reduce using rule 39 (binop -> exp Equality exp .)
    Different       reduce using rule 39 (binop -> exp Equality exp .)
    RParen          reduce using rule 39 (binop -> exp Equality exp .)
    COMMA           reduce using rule 39 (binop -> exp Equality exp .)
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66

  ! Multiply        [ reduce using rule 39 (binop -> exp Equality exp .) ]
  ! PLUS            [ reduce using rule 39 (binop -> exp Equality exp .) ]
  ! Divide          [ reduce using rule 39 (binop -> exp Equality exp .) ]
  ! Minus           [ reduce using rule 39 (binop -> exp Equality exp .) ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 84

    (40) binop -> exp Different exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 40 (binop -> exp Different exp .)
    Equality        reduce using rule 40 (binop -> exp Different exp .)
    Different       reduce using rule 40 (binop -> exp Different exp .)
    RParen          reduce using rule 40 (binop -> exp Different exp .)
    COMMA           reduce using rule 40 (binop -> exp Different exp .)
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66

  ! Multiply        [ reduce using rule 40 (binop -> exp Different exp .) ]
  ! PLUS            [ reduce using rule 40 (binop -> exp Different exp .) ]
  ! Divide          [ reduce using rule 40 (binop -> exp Different exp .) ]
  ! Minus           [ reduce using rule 40 (binop -> exp Different exp .) ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 85

    (18) stmt -> vdecl Equal exp . Semicolon
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       shift and go to state 95
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 86

    (20) stmt -> While LParen exp . RParen stmt
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    RParen          shift and go to state 96
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 87

    (27) exp -> LParen exp RParen .

    Semicolon       reduce using rule 27 (exp -> LParen exp RParen .)
    Multiply        reduce using rule 27 (exp -> LParen exp RParen .)
    PLUS            reduce using rule 27 (exp -> LParen exp RParen .)
    Divide          reduce using rule 27 (exp -> LParen exp RParen .)
    Minus           reduce using rule 27 (exp -> LParen exp RParen .)
    Equality        reduce using rule 27 (exp -> LParen exp RParen .)
    Different       reduce using rule 27 (exp -> LParen exp RParen .)
    RParen          reduce using rule 27 (exp -> LParen exp RParen .)
    COMMA           reduce using rule 27 (exp -> LParen exp RParen .)


state 88

    (21) stmt -> If LParen exp . RParen stmt
    (22) stmt -> If LParen exp . RParen stmt Else stmt
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    RParen          shift and go to state 97
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 89

    (23) stmt -> Print exp Semicolon .

    Return          reduce using rule 23 (stmt -> Print exp Semicolon .)
    While           reduce using rule 23 (stmt -> Print exp Semicolon .)
    If              reduce using rule 23 (stmt -> Print exp Semicolon .)
    Print           reduce using rule 23 (stmt -> Print exp Semicolon .)
    Array           reduce using rule 23 (stmt -> Print exp Semicolon .)
    LBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    LParen          reduce using rule 23 (stmt -> Print exp Semicolon .)
    lit             reduce using rule 23 (stmt -> Print exp Semicolon .)
    GLOBID          reduce using rule 23 (stmt -> Print exp Semicolon .)
    int             reduce using rule 23 (stmt -> Print exp Semicolon .)
    void            reduce using rule 23 (stmt -> Print exp Semicolon .)
    ref             reduce using rule 23 (stmt -> Print exp Semicolon .)
    noalias         reduce using rule 23 (stmt -> Print exp Semicolon .)
    RBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    Else            reduce using rule 23 (stmt -> Print exp Semicolon .)


state 90

    (24) stmt -> Array LSquare lit . RSquare

    RSquare         shift and go to state 98


state 91

    (38) binop -> GLOBID Equal exp .
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    Semicolon       reduce using rule 38 (binop -> GLOBID Equal exp .)
    RParen          reduce using rule 38 (binop -> GLOBID Equal exp .)
    COMMA           reduce using rule 38 (binop -> GLOBID Equal exp .)
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68

  ! Multiply        [ reduce using rule 38 (binop -> GLOBID Equal exp .) ]
  ! PLUS            [ reduce using rule 38 (binop -> GLOBID Equal exp .) ]
  ! Divide          [ reduce using rule 38 (binop -> GLOBID Equal exp .) ]
  ! Minus           [ reduce using rule 38 (binop -> GLOBID Equal exp .) ]
  ! Equality        [ reduce using rule 38 (binop -> GLOBID Equal exp .) ]
  ! Different       [ reduce using rule 38 (binop -> GLOBID Equal exp .) ]


state 92

    (32) expWrapper -> LParen RParen .

    Semicolon       reduce using rule 32 (expWrapper -> LParen RParen .)
    Multiply        reduce using rule 32 (expWrapper -> LParen RParen .)
    PLUS            reduce using rule 32 (expWrapper -> LParen RParen .)
    Divide          reduce using rule 32 (expWrapper -> LParen RParen .)
    Minus           reduce using rule 32 (expWrapper -> LParen RParen .)
    Equality        reduce using rule 32 (expWrapper -> LParen RParen .)
    Different       reduce using rule 32 (expWrapper -> LParen RParen .)
    RParen          reduce using rule 32 (expWrapper -> LParen RParen .)
    COMMA           reduce using rule 32 (expWrapper -> LParen RParen .)


state 93

    (33) expWrapper -> LParen exps . RParen

    RParen          shift and go to state 99


state 94

    (25) exps -> exp .
    (26) exps -> exp . COMMA exps
    (34) binop -> exp . Multiply exp
    (35) binop -> exp . PLUS exp
    (36) binop -> exp . Divide exp
    (37) binop -> exp . Minus exp
    (39) binop -> exp . Equality exp
    (40) binop -> exp . Different exp

    RParen          reduce using rule 25 (exps -> exp .)
    COMMA           shift and go to state 100
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 95

    (18) stmt -> vdecl Equal exp Semicolon .

    Return          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    While           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    If              reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Print           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Array           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LParen          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    lit             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    GLOBID          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    int             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    void            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    ref             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    noalias         reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    RBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Else            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)


state 96

    (20) stmt -> While LParen exp RParen . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (43) vdecl -> . TYPE GLOBID
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 101
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 97

    (21) stmt -> If LParen exp RParen . stmt
    (22) stmt -> If LParen exp RParen . stmt Else stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (43) vdecl -> . TYPE GLOBID
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 102
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 98

    (24) stmt -> Array LSquare lit RSquare .

    Return          reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    While           reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    If              reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    Print           reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    Array           reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    LBracket        reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    LParen          reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    lit             reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    GLOBID          reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    int             reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    void            reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    ref             reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    noalias         reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    RBracket        reduce using rule 24 (stmt -> Array LSquare lit RSquare .)
    Else            reduce using rule 24 (stmt -> Array LSquare lit RSquare .)


state 99

    (33) expWrapper -> LParen exps RParen .

    Semicolon       reduce using rule 33 (expWrapper -> LParen exps RParen .)
    Multiply        reduce using rule 33 (expWrapper -> LParen exps RParen .)
    PLUS            reduce using rule 33 (expWrapper -> LParen exps RParen .)
    Divide          reduce using rule 33 (expWrapper -> LParen exps RParen .)
    Minus           reduce using rule 33 (expWrapper -> LParen exps RParen .)
    Equality        reduce using rule 33 (expWrapper -> LParen exps RParen .)
    Different       reduce using rule 33 (expWrapper -> LParen exps RParen .)
    RParen          reduce using rule 33 (expWrapper -> LParen exps RParen .)
    COMMA           reduce using rule 33 (expWrapper -> LParen exps RParen .)


state 100

    (26) exps -> exp COMMA . exps
    (25) exps -> . exp
    (26) exps -> . exp COMMA exps
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52

    exp                            shift and go to state 94
    exps                           shift and go to state 103
    binop                          shift and go to state 53

state 101

    (20) stmt -> While LParen exp RParen stmt .

    Return          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    While           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    If              reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Print           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Array           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LParen          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    lit             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    GLOBID          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    int             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    void            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    ref             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    noalias         reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    RBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Else            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)


state 102

    (21) stmt -> If LParen exp RParen stmt .
    (22) stmt -> If LParen exp RParen stmt . Else stmt

  ! shift/reduce conflict for Else resolved as shift
    Return          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    While           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    If              reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Print           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Array           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LParen          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    lit             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    GLOBID          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    int             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    void            reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    ref             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    noalias         reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    RBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Else            shift and go to state 104

  ! Else            [ reduce using rule 21 (stmt -> If LParen exp RParen stmt .) ]


state 103

    (26) exps -> exp COMMA exps .

    RParen          reduce using rule 26 (exps -> exp COMMA exps .)


state 104

    (22) stmt -> If LParen exp RParen stmt Else . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (43) vdecl -> . TYPE GLOBID
    (27) exp -> . LParen exp RParen
    (28) exp -> . lit
    (29) exp -> . binop
    (30) exp -> . GLOBID
    (31) exp -> . GLOBID expWrapper
    (46) TYPE -> . int
    (47) TYPE -> . void
    (48) TYPE -> . ref TYPE
    (49) TYPE -> . noalias ref TYPE
    (34) binop -> . exp Multiply exp
    (35) binop -> . exp PLUS exp
    (36) binop -> . exp Divide exp
    (37) binop -> . exp Minus exp
    (38) binop -> . GLOBID Equal exp
    (39) binop -> . exp Equality exp
    (40) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 52
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 105
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 105

    (22) stmt -> If LParen exp RParen stmt Else stmt .

    Return          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    While           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    If              reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Print           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Array           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LParen          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    lit             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    GLOBID          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    int             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    void            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    ref             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    noalias         reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    RBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Else            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for Else in state 102 resolved as shift
