Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> funcs
Rule 2     prog -> externs funcs
Rule 3     externs -> extern
Rule 4     externs -> extern externs
Rule 5     funcs -> func
Rule 6     funcs -> func funcs
Rule 7     extern -> EXTERN TYPE GLOBID LParen RParen Semicolon
Rule 8     extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon
Rule 9     func -> DEF TYPE GLOBID LParen RParen blk
Rule 10    func -> DEF TYPE GLOBID LParen vdecls RParen blk
Rule 11    blk -> LBracket stmts RBracket
Rule 12    blk -> LBracket RBracket
Rule 13    stmts -> stmt
Rule 14    stmts -> stmt stmts
Rule 15    stmt -> blk
Rule 16    stmt -> Return Semicolon
Rule 17    stmt -> Return exp Semicolon
Rule 18    stmt -> vdecl Equal exp Semicolon
Rule 19    stmt -> exp Semicolon
Rule 20    stmt -> While LParen exp RParen stmt
Rule 21    stmt -> If LParen exp RParen stmt
Rule 22    stmt -> If LParen exp RParen stmt Else stmt
Rule 23    stmt -> Print exp Semicolon
Rule 24    stmt -> GLOBID Equal Vector Semicolon
Rule 25    Vector -> Array LSquare RSquare
Rule 26    Vector -> Array LSquare lit RSquare
Rule 27    Vector -> Array LSquare GLOBID RSquare
Rule 28    exps -> exp
Rule 29    exps -> exp COMMA exps
Rule 30    exp -> LParen exp RParen
Rule 31    exp -> lit
Rule 32    exp -> binop
Rule 33    exp -> GLOBID
Rule 34    exp -> GLOBID expWrapper
Rule 35    expWrapper -> LParen RParen
Rule 36    expWrapper -> LParen exps RParen
Rule 37    binop -> exp Multiply exp
Rule 38    binop -> exp PLUS exp
Rule 39    binop -> exp Divide exp
Rule 40    binop -> exp Minus exp
Rule 41    binop -> GLOBID Equal exp
Rule 42    binop -> exp Equality exp
Rule 43    binop -> exp Different exp
Rule 44    vdecls -> vdecl COMMA vdecls
Rule 45    vdecls -> vdecl
Rule 46    vdecl -> TYPE GLOBID
Rule 47    tdecls -> TYPE
Rule 48    tdecls -> TYPE COMMA tdecls
Rule 49    TYPE -> int
Rule 50    TYPE -> void
Rule 51    TYPE -> ref TYPE
Rule 52    TYPE -> noalias ref TYPE

Terminals, with rules where they appear

Array                : 25 26 27
COMMA                : 29 44 48
DEF                  : 9 10
Different            : 43
Divide               : 39
EXTERN               : 7 8
Else                 : 22
Equal                : 18 24 41
Equality             : 42
GLOBID               : 7 8 9 10 24 27 33 34 41 46
If                   : 21 22
LBracket             : 11 12
LParen               : 7 8 9 10 20 21 22 30 35 36
LSquare              : 25 26 27
Minus                : 40
Multiply             : 37
PLUS                 : 38
Print                : 23
RBracket             : 11 12
RParen               : 7 8 9 10 20 21 22 30 35 36
RSquare              : 25 26 27
Return               : 16 17
Semicolon            : 7 8 16 17 18 19 23 24
While                : 20
error                : 
int                  : 49
lit                  : 26 31
noalias              : 52
ref                  : 51 52
void                 : 50

Nonterminals, with rules where they appear

TYPE                 : 7 8 9 10 46 47 48 51 52
Vector               : 24
binop                : 32
blk                  : 9 10 15
exp                  : 17 18 19 20 21 22 23 28 29 30 37 37 38 38 39 39 40 40 41 42 42 43 43
expWrapper           : 34
exps                 : 29 36
extern               : 3 4
externs              : 2 4
func                 : 5 6
funcs                : 1 2 6
prog                 : 0
stmt                 : 13 14 20 21 22 22
stmts                : 11 14
tdecls               : 8 48
vdecl                : 18 44 45
vdecls               : 10 44

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . funcs
    (2) prog -> . externs funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             shift and go to state 6
    EXTERN          shift and go to state 7

    prog                           shift and go to state 1
    funcs                          shift and go to state 2
    externs                        shift and go to state 3
    func                           shift and go to state 4
    extern                         shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> funcs .

    $end            reduce using rule 1 (prog -> funcs .)


state 3

    (2) prog -> externs . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    DEF             shift and go to state 6

    funcs                          shift and go to state 8
    func                           shift and go to state 4

state 4

    (5) funcs -> func .
    (6) funcs -> func . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    $end            reduce using rule 5 (funcs -> func .)
    DEF             shift and go to state 6

    func                           shift and go to state 4
    funcs                          shift and go to state 9

state 5

    (3) externs -> extern .
    (4) externs -> extern . externs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             reduce using rule 3 (externs -> extern .)
    EXTERN          shift and go to state 7

    extern                         shift and go to state 5
    externs                        shift and go to state 10

state 6

    (9) func -> DEF . TYPE GLOBID LParen RParen blk
    (10) func -> DEF . TYPE GLOBID LParen vdecls RParen blk
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 11

state 7

    (7) extern -> EXTERN . TYPE GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN . TYPE GLOBID LParen tdecls RParen Semicolon
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 16

state 8

    (2) prog -> externs funcs .

    $end            reduce using rule 2 (prog -> externs funcs .)


state 9

    (6) funcs -> func funcs .

    $end            reduce using rule 6 (funcs -> func funcs .)


state 10

    (4) externs -> extern externs .

    DEF             reduce using rule 4 (externs -> extern externs .)


state 11

    (9) func -> DEF TYPE . GLOBID LParen RParen blk
    (10) func -> DEF TYPE . GLOBID LParen vdecls RParen blk

    GLOBID          shift and go to state 17


state 12

    (49) TYPE -> int .

    GLOBID          reduce using rule 49 (TYPE -> int .)
    COMMA           reduce using rule 49 (TYPE -> int .)
    RParen          reduce using rule 49 (TYPE -> int .)


state 13

    (50) TYPE -> void .

    GLOBID          reduce using rule 50 (TYPE -> void .)
    COMMA           reduce using rule 50 (TYPE -> void .)
    RParen          reduce using rule 50 (TYPE -> void .)


state 14

    (51) TYPE -> ref . TYPE
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 18

state 15

    (52) TYPE -> noalias . ref TYPE

    ref             shift and go to state 19


state 16

    (7) extern -> EXTERN TYPE . GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN TYPE . GLOBID LParen tdecls RParen Semicolon

    GLOBID          shift and go to state 20


state 17

    (9) func -> DEF TYPE GLOBID . LParen RParen blk
    (10) func -> DEF TYPE GLOBID . LParen vdecls RParen blk

    LParen          shift and go to state 21


state 18

    (51) TYPE -> ref TYPE .

    GLOBID          reduce using rule 51 (TYPE -> ref TYPE .)
    COMMA           reduce using rule 51 (TYPE -> ref TYPE .)
    RParen          reduce using rule 51 (TYPE -> ref TYPE .)


state 19

    (52) TYPE -> noalias ref . TYPE
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 22

state 20

    (7) extern -> EXTERN TYPE GLOBID . LParen RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID . LParen tdecls RParen Semicolon

    LParen          shift and go to state 23


state 21

    (9) func -> DEF TYPE GLOBID LParen . RParen blk
    (10) func -> DEF TYPE GLOBID LParen . vdecls RParen blk
    (44) vdecls -> . vdecl COMMA vdecls
    (45) vdecls -> . vdecl
    (46) vdecl -> . TYPE GLOBID
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 25
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 24
    vdecls                         shift and go to state 26
    vdecl                          shift and go to state 27

state 22

    (52) TYPE -> noalias ref TYPE .

    GLOBID          reduce using rule 52 (TYPE -> noalias ref TYPE .)
    COMMA           reduce using rule 52 (TYPE -> noalias ref TYPE .)
    RParen          reduce using rule 52 (TYPE -> noalias ref TYPE .)


state 23

    (7) extern -> EXTERN TYPE GLOBID LParen . RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID LParen . tdecls RParen Semicolon
    (47) tdecls -> . TYPE
    (48) tdecls -> . TYPE COMMA tdecls
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 29
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 28
    tdecls                         shift and go to state 30

state 24

    (46) vdecl -> TYPE . GLOBID

    GLOBID          shift and go to state 31


state 25

    (9) func -> DEF TYPE GLOBID LParen RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 33

    blk                            shift and go to state 32

state 26

    (10) func -> DEF TYPE GLOBID LParen vdecls . RParen blk

    RParen          shift and go to state 34


state 27

    (44) vdecls -> vdecl . COMMA vdecls
    (45) vdecls -> vdecl .

    COMMA           shift and go to state 35
    RParen          reduce using rule 45 (vdecls -> vdecl .)


state 28

    (47) tdecls -> TYPE .
    (48) tdecls -> TYPE . COMMA tdecls

    RParen          reduce using rule 47 (tdecls -> TYPE .)
    COMMA           shift and go to state 36


state 29

    (7) extern -> EXTERN TYPE GLOBID LParen RParen . Semicolon

    Semicolon       shift and go to state 37


state 30

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls . RParen Semicolon

    RParen          shift and go to state 38


state 31

    (46) vdecl -> TYPE GLOBID .

    COMMA           reduce using rule 46 (vdecl -> TYPE GLOBID .)
    RParen          reduce using rule 46 (vdecl -> TYPE GLOBID .)
    Equal           reduce using rule 46 (vdecl -> TYPE GLOBID .)


state 32

    (9) func -> DEF TYPE GLOBID LParen RParen blk .

    DEF             reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)
    $end            reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)


state 33

    (11) blk -> LBracket . stmts RBracket
    (12) blk -> LBracket . RBracket
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (46) vdecl -> . TYPE GLOBID
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    RBracket        shift and go to state 40
    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    GLOBID          shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    stmts                          shift and go to state 39
    stmt                           shift and go to state 41
    blk                            shift and go to state 42
    exp                            shift and go to state 44
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 52

state 34

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 33

    blk                            shift and go to state 53

state 35

    (44) vdecls -> vdecl COMMA . vdecls
    (44) vdecls -> . vdecl COMMA vdecls
    (45) vdecls -> . vdecl
    (46) vdecl -> . TYPE GLOBID
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    vdecl                          shift and go to state 27
    vdecls                         shift and go to state 54
    TYPE                           shift and go to state 24

state 36

    (48) tdecls -> TYPE COMMA . tdecls
    (47) tdecls -> . TYPE
    (48) tdecls -> . TYPE COMMA tdecls
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 28
    tdecls                         shift and go to state 55

state 37

    (7) extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .

    EXTERN          reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)
    DEF             reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)


state 38

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen . Semicolon

    Semicolon       shift and go to state 56


state 39

    (11) blk -> LBracket stmts . RBracket

    RBracket        shift and go to state 57


state 40

    (12) blk -> LBracket RBracket .

    DEF             reduce using rule 12 (blk -> LBracket RBracket .)
    $end            reduce using rule 12 (blk -> LBracket RBracket .)
    Return          reduce using rule 12 (blk -> LBracket RBracket .)
    While           reduce using rule 12 (blk -> LBracket RBracket .)
    If              reduce using rule 12 (blk -> LBracket RBracket .)
    Print           reduce using rule 12 (blk -> LBracket RBracket .)
    GLOBID          reduce using rule 12 (blk -> LBracket RBracket .)
    LBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    LParen          reduce using rule 12 (blk -> LBracket RBracket .)
    lit             reduce using rule 12 (blk -> LBracket RBracket .)
    int             reduce using rule 12 (blk -> LBracket RBracket .)
    void            reduce using rule 12 (blk -> LBracket RBracket .)
    ref             reduce using rule 12 (blk -> LBracket RBracket .)
    noalias         reduce using rule 12 (blk -> LBracket RBracket .)
    RBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    Else            reduce using rule 12 (blk -> LBracket RBracket .)


state 41

    (13) stmts -> stmt .
    (14) stmts -> stmt . stmts
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (46) vdecl -> . TYPE GLOBID
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    RBracket        reduce using rule 13 (stmts -> stmt .)
    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    GLOBID          shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    stmt                           shift and go to state 41
    stmts                          shift and go to state 58
    blk                            shift and go to state 42
    exp                            shift and go to state 44
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 52

state 42

    (15) stmt -> blk .

    Return          reduce using rule 15 (stmt -> blk .)
    While           reduce using rule 15 (stmt -> blk .)
    If              reduce using rule 15 (stmt -> blk .)
    Print           reduce using rule 15 (stmt -> blk .)
    GLOBID          reduce using rule 15 (stmt -> blk .)
    LBracket        reduce using rule 15 (stmt -> blk .)
    LParen          reduce using rule 15 (stmt -> blk .)
    lit             reduce using rule 15 (stmt -> blk .)
    int             reduce using rule 15 (stmt -> blk .)
    void            reduce using rule 15 (stmt -> blk .)
    ref             reduce using rule 15 (stmt -> blk .)
    noalias         reduce using rule 15 (stmt -> blk .)
    RBracket        reduce using rule 15 (stmt -> blk .)
    Else            reduce using rule 15 (stmt -> blk .)


state 43

    (16) stmt -> Return . Semicolon
    (17) stmt -> Return . exp Semicolon
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    Semicolon       shift and go to state 59
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 60
    binop                          shift and go to state 52

state 44

    (19) stmt -> exp . Semicolon
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       shift and go to state 62
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 45

    (18) stmt -> vdecl . Equal exp Semicolon

    Equal           shift and go to state 69


state 46

    (20) stmt -> While . LParen exp RParen stmt

    LParen          shift and go to state 70


state 47

    (30) exp -> LParen . exp RParen
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 71
    binop                          shift and go to state 52

state 48

    (21) stmt -> If . LParen exp RParen stmt
    (22) stmt -> If . LParen exp RParen stmt Else stmt

    LParen          shift and go to state 72


state 49

    (23) stmt -> Print . exp Semicolon
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 73
    binop                          shift and go to state 52

state 50

    (24) stmt -> GLOBID . Equal Vector Semicolon
    (33) exp -> GLOBID .
    (34) exp -> GLOBID . expWrapper
    (41) binop -> GLOBID . Equal exp
    (35) expWrapper -> . LParen RParen
    (36) expWrapper -> . LParen exps RParen

    Equal           shift and go to state 74
    Semicolon       reduce using rule 33 (exp -> GLOBID .)
    Multiply        reduce using rule 33 (exp -> GLOBID .)
    PLUS            reduce using rule 33 (exp -> GLOBID .)
    Divide          reduce using rule 33 (exp -> GLOBID .)
    Minus           reduce using rule 33 (exp -> GLOBID .)
    Equality        reduce using rule 33 (exp -> GLOBID .)
    Different       reduce using rule 33 (exp -> GLOBID .)
    LParen          shift and go to state 76

    expWrapper                     shift and go to state 75

state 51

    (31) exp -> lit .

    Semicolon       reduce using rule 31 (exp -> lit .)
    Multiply        reduce using rule 31 (exp -> lit .)
    PLUS            reduce using rule 31 (exp -> lit .)
    Divide          reduce using rule 31 (exp -> lit .)
    Minus           reduce using rule 31 (exp -> lit .)
    Equality        reduce using rule 31 (exp -> lit .)
    Different       reduce using rule 31 (exp -> lit .)
    RParen          reduce using rule 31 (exp -> lit .)
    COMMA           reduce using rule 31 (exp -> lit .)


state 52

    (32) exp -> binop .

    Semicolon       reduce using rule 32 (exp -> binop .)
    Multiply        reduce using rule 32 (exp -> binop .)
    PLUS            reduce using rule 32 (exp -> binop .)
    Divide          reduce using rule 32 (exp -> binop .)
    Minus           reduce using rule 32 (exp -> binop .)
    Equality        reduce using rule 32 (exp -> binop .)
    Different       reduce using rule 32 (exp -> binop .)
    RParen          reduce using rule 32 (exp -> binop .)
    COMMA           reduce using rule 32 (exp -> binop .)


state 53

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen blk .

    DEF             reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)
    $end            reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)


state 54

    (44) vdecls -> vdecl COMMA vdecls .

    RParen          reduce using rule 44 (vdecls -> vdecl COMMA vdecls .)


state 55

    (48) tdecls -> TYPE COMMA tdecls .

    RParen          reduce using rule 48 (tdecls -> TYPE COMMA tdecls .)


state 56

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .

    EXTERN          reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)
    DEF             reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)


state 57

    (11) blk -> LBracket stmts RBracket .

    DEF             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    $end            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Return          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    While           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    If              reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Print           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    GLOBID          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LParen          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    lit             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    int             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    void            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    ref             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    noalias         reduce using rule 11 (blk -> LBracket stmts RBracket .)
    RBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Else            reduce using rule 11 (blk -> LBracket stmts RBracket .)


state 58

    (14) stmts -> stmt stmts .

    RBracket        reduce using rule 14 (stmts -> stmt stmts .)


state 59

    (16) stmt -> Return Semicolon .

    Return          reduce using rule 16 (stmt -> Return Semicolon .)
    While           reduce using rule 16 (stmt -> Return Semicolon .)
    If              reduce using rule 16 (stmt -> Return Semicolon .)
    Print           reduce using rule 16 (stmt -> Return Semicolon .)
    GLOBID          reduce using rule 16 (stmt -> Return Semicolon .)
    LBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    LParen          reduce using rule 16 (stmt -> Return Semicolon .)
    lit             reduce using rule 16 (stmt -> Return Semicolon .)
    int             reduce using rule 16 (stmt -> Return Semicolon .)
    void            reduce using rule 16 (stmt -> Return Semicolon .)
    ref             reduce using rule 16 (stmt -> Return Semicolon .)
    noalias         reduce using rule 16 (stmt -> Return Semicolon .)
    RBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    Else            reduce using rule 16 (stmt -> Return Semicolon .)


state 60

    (17) stmt -> Return exp . Semicolon
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       shift and go to state 77
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 61

    (33) exp -> GLOBID .
    (34) exp -> GLOBID . expWrapper
    (41) binop -> GLOBID . Equal exp
    (35) expWrapper -> . LParen RParen
    (36) expWrapper -> . LParen exps RParen

    Semicolon       reduce using rule 33 (exp -> GLOBID .)
    Multiply        reduce using rule 33 (exp -> GLOBID .)
    PLUS            reduce using rule 33 (exp -> GLOBID .)
    Divide          reduce using rule 33 (exp -> GLOBID .)
    Minus           reduce using rule 33 (exp -> GLOBID .)
    Equality        reduce using rule 33 (exp -> GLOBID .)
    Different       reduce using rule 33 (exp -> GLOBID .)
    RParen          reduce using rule 33 (exp -> GLOBID .)
    COMMA           reduce using rule 33 (exp -> GLOBID .)
    Equal           shift and go to state 78
    LParen          shift and go to state 76

    expWrapper                     shift and go to state 75

state 62

    (19) stmt -> exp Semicolon .

    Return          reduce using rule 19 (stmt -> exp Semicolon .)
    While           reduce using rule 19 (stmt -> exp Semicolon .)
    If              reduce using rule 19 (stmt -> exp Semicolon .)
    Print           reduce using rule 19 (stmt -> exp Semicolon .)
    GLOBID          reduce using rule 19 (stmt -> exp Semicolon .)
    LBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    LParen          reduce using rule 19 (stmt -> exp Semicolon .)
    lit             reduce using rule 19 (stmt -> exp Semicolon .)
    int             reduce using rule 19 (stmt -> exp Semicolon .)
    void            reduce using rule 19 (stmt -> exp Semicolon .)
    ref             reduce using rule 19 (stmt -> exp Semicolon .)
    noalias         reduce using rule 19 (stmt -> exp Semicolon .)
    RBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    Else            reduce using rule 19 (stmt -> exp Semicolon .)


state 63

    (37) binop -> exp Multiply . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 79
    binop                          shift and go to state 52

state 64

    (38) binop -> exp PLUS . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 80
    binop                          shift and go to state 52

state 65

    (39) binop -> exp Divide . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 81
    binop                          shift and go to state 52

state 66

    (40) binop -> exp Minus . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 82
    binop                          shift and go to state 52

state 67

    (42) binop -> exp Equality . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 83
    binop                          shift and go to state 52

state 68

    (43) binop -> exp Different . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 84
    binop                          shift and go to state 52

state 69

    (18) stmt -> vdecl Equal . exp Semicolon
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 85
    binop                          shift and go to state 52

state 70

    (20) stmt -> While LParen . exp RParen stmt
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 86
    binop                          shift and go to state 52

state 71

    (30) exp -> LParen exp . RParen
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    RParen          shift and go to state 87
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 72

    (21) stmt -> If LParen . exp RParen stmt
    (22) stmt -> If LParen . exp RParen stmt Else stmt
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 88
    binop                          shift and go to state 52

state 73

    (23) stmt -> Print exp . Semicolon
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       shift and go to state 89
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 74

    (24) stmt -> GLOBID Equal . Vector Semicolon
    (41) binop -> GLOBID Equal . exp
    (25) Vector -> . Array LSquare RSquare
    (26) Vector -> . Array LSquare lit RSquare
    (27) Vector -> . Array LSquare GLOBID RSquare
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    Array           shift and go to state 92
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    Vector                         shift and go to state 90
    exp                            shift and go to state 91
    binop                          shift and go to state 52

state 75

    (34) exp -> GLOBID expWrapper .

    Semicolon       reduce using rule 34 (exp -> GLOBID expWrapper .)
    Multiply        reduce using rule 34 (exp -> GLOBID expWrapper .)
    PLUS            reduce using rule 34 (exp -> GLOBID expWrapper .)
    Divide          reduce using rule 34 (exp -> GLOBID expWrapper .)
    Minus           reduce using rule 34 (exp -> GLOBID expWrapper .)
    Equality        reduce using rule 34 (exp -> GLOBID expWrapper .)
    Different       reduce using rule 34 (exp -> GLOBID expWrapper .)
    RParen          reduce using rule 34 (exp -> GLOBID expWrapper .)
    COMMA           reduce using rule 34 (exp -> GLOBID expWrapper .)


state 76

    (35) expWrapper -> LParen . RParen
    (36) expWrapper -> LParen . exps RParen
    (28) exps -> . exp
    (29) exps -> . exp COMMA exps
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    RParen          shift and go to state 93
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exps                           shift and go to state 94
    exp                            shift and go to state 95
    binop                          shift and go to state 52

state 77

    (17) stmt -> Return exp Semicolon .

    Return          reduce using rule 17 (stmt -> Return exp Semicolon .)
    While           reduce using rule 17 (stmt -> Return exp Semicolon .)
    If              reduce using rule 17 (stmt -> Return exp Semicolon .)
    Print           reduce using rule 17 (stmt -> Return exp Semicolon .)
    GLOBID          reduce using rule 17 (stmt -> Return exp Semicolon .)
    LBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    LParen          reduce using rule 17 (stmt -> Return exp Semicolon .)
    lit             reduce using rule 17 (stmt -> Return exp Semicolon .)
    int             reduce using rule 17 (stmt -> Return exp Semicolon .)
    void            reduce using rule 17 (stmt -> Return exp Semicolon .)
    ref             reduce using rule 17 (stmt -> Return exp Semicolon .)
    noalias         reduce using rule 17 (stmt -> Return exp Semicolon .)
    RBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    Else            reduce using rule 17 (stmt -> Return exp Semicolon .)


state 78

    (41) binop -> GLOBID Equal . exp
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 91
    binop                          shift and go to state 52

state 79

    (37) binop -> exp Multiply exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 37 (binop -> exp Multiply exp .)
    Multiply        reduce using rule 37 (binop -> exp Multiply exp .)
    PLUS            reduce using rule 37 (binop -> exp Multiply exp .)
    Divide          reduce using rule 37 (binop -> exp Multiply exp .)
    Minus           reduce using rule 37 (binop -> exp Multiply exp .)
    Equality        reduce using rule 37 (binop -> exp Multiply exp .)
    Different       reduce using rule 37 (binop -> exp Multiply exp .)
    RParen          reduce using rule 37 (binop -> exp Multiply exp .)
    COMMA           reduce using rule 37 (binop -> exp Multiply exp .)

  ! Multiply        [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! Divide          [ shift and go to state 65 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 80

    (38) binop -> exp PLUS exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 38 (binop -> exp PLUS exp .)
    PLUS            reduce using rule 38 (binop -> exp PLUS exp .)
    Minus           reduce using rule 38 (binop -> exp PLUS exp .)
    Equality        reduce using rule 38 (binop -> exp PLUS exp .)
    Different       reduce using rule 38 (binop -> exp PLUS exp .)
    RParen          reduce using rule 38 (binop -> exp PLUS exp .)
    COMMA           reduce using rule 38 (binop -> exp PLUS exp .)
    Multiply        shift and go to state 63
    Divide          shift and go to state 65

  ! Multiply        [ reduce using rule 38 (binop -> exp PLUS exp .) ]
  ! Divide          [ reduce using rule 38 (binop -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 81

    (39) binop -> exp Divide exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 39 (binop -> exp Divide exp .)
    Multiply        reduce using rule 39 (binop -> exp Divide exp .)
    PLUS            reduce using rule 39 (binop -> exp Divide exp .)
    Divide          reduce using rule 39 (binop -> exp Divide exp .)
    Minus           reduce using rule 39 (binop -> exp Divide exp .)
    Equality        reduce using rule 39 (binop -> exp Divide exp .)
    Different       reduce using rule 39 (binop -> exp Divide exp .)
    RParen          reduce using rule 39 (binop -> exp Divide exp .)
    COMMA           reduce using rule 39 (binop -> exp Divide exp .)

  ! Multiply        [ shift and go to state 63 ]
  ! PLUS            [ shift and go to state 64 ]
  ! Divide          [ shift and go to state 65 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 82

    (40) binop -> exp Minus exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 40 (binop -> exp Minus exp .)
    PLUS            reduce using rule 40 (binop -> exp Minus exp .)
    Minus           reduce using rule 40 (binop -> exp Minus exp .)
    Equality        reduce using rule 40 (binop -> exp Minus exp .)
    Different       reduce using rule 40 (binop -> exp Minus exp .)
    RParen          reduce using rule 40 (binop -> exp Minus exp .)
    COMMA           reduce using rule 40 (binop -> exp Minus exp .)
    Multiply        shift and go to state 63
    Divide          shift and go to state 65

  ! Multiply        [ reduce using rule 40 (binop -> exp Minus exp .) ]
  ! Divide          [ reduce using rule 40 (binop -> exp Minus exp .) ]
  ! PLUS            [ shift and go to state 64 ]
  ! Minus           [ shift and go to state 66 ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 83

    (42) binop -> exp Equality exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 42 (binop -> exp Equality exp .)
    Equality        reduce using rule 42 (binop -> exp Equality exp .)
    Different       reduce using rule 42 (binop -> exp Equality exp .)
    RParen          reduce using rule 42 (binop -> exp Equality exp .)
    COMMA           reduce using rule 42 (binop -> exp Equality exp .)
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66

  ! Multiply        [ reduce using rule 42 (binop -> exp Equality exp .) ]
  ! PLUS            [ reduce using rule 42 (binop -> exp Equality exp .) ]
  ! Divide          [ reduce using rule 42 (binop -> exp Equality exp .) ]
  ! Minus           [ reduce using rule 42 (binop -> exp Equality exp .) ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 84

    (43) binop -> exp Different exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 43 (binop -> exp Different exp .)
    Equality        reduce using rule 43 (binop -> exp Different exp .)
    Different       reduce using rule 43 (binop -> exp Different exp .)
    RParen          reduce using rule 43 (binop -> exp Different exp .)
    COMMA           reduce using rule 43 (binop -> exp Different exp .)
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66

  ! Multiply        [ reduce using rule 43 (binop -> exp Different exp .) ]
  ! PLUS            [ reduce using rule 43 (binop -> exp Different exp .) ]
  ! Divide          [ reduce using rule 43 (binop -> exp Different exp .) ]
  ! Minus           [ reduce using rule 43 (binop -> exp Different exp .) ]
  ! Equality        [ shift and go to state 67 ]
  ! Different       [ shift and go to state 68 ]


state 85

    (18) stmt -> vdecl Equal exp . Semicolon
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       shift and go to state 96
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 86

    (20) stmt -> While LParen exp . RParen stmt
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    RParen          shift and go to state 97
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 87

    (30) exp -> LParen exp RParen .

    Semicolon       reduce using rule 30 (exp -> LParen exp RParen .)
    Multiply        reduce using rule 30 (exp -> LParen exp RParen .)
    PLUS            reduce using rule 30 (exp -> LParen exp RParen .)
    Divide          reduce using rule 30 (exp -> LParen exp RParen .)
    Minus           reduce using rule 30 (exp -> LParen exp RParen .)
    Equality        reduce using rule 30 (exp -> LParen exp RParen .)
    Different       reduce using rule 30 (exp -> LParen exp RParen .)
    RParen          reduce using rule 30 (exp -> LParen exp RParen .)
    COMMA           reduce using rule 30 (exp -> LParen exp RParen .)


state 88

    (21) stmt -> If LParen exp . RParen stmt
    (22) stmt -> If LParen exp . RParen stmt Else stmt
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    RParen          shift and go to state 98
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 89

    (23) stmt -> Print exp Semicolon .

    Return          reduce using rule 23 (stmt -> Print exp Semicolon .)
    While           reduce using rule 23 (stmt -> Print exp Semicolon .)
    If              reduce using rule 23 (stmt -> Print exp Semicolon .)
    Print           reduce using rule 23 (stmt -> Print exp Semicolon .)
    GLOBID          reduce using rule 23 (stmt -> Print exp Semicolon .)
    LBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    LParen          reduce using rule 23 (stmt -> Print exp Semicolon .)
    lit             reduce using rule 23 (stmt -> Print exp Semicolon .)
    int             reduce using rule 23 (stmt -> Print exp Semicolon .)
    void            reduce using rule 23 (stmt -> Print exp Semicolon .)
    ref             reduce using rule 23 (stmt -> Print exp Semicolon .)
    noalias         reduce using rule 23 (stmt -> Print exp Semicolon .)
    RBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    Else            reduce using rule 23 (stmt -> Print exp Semicolon .)


state 90

    (24) stmt -> GLOBID Equal Vector . Semicolon

    Semicolon       shift and go to state 99


state 91

    (41) binop -> GLOBID Equal exp .
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    Semicolon       reduce using rule 41 (binop -> GLOBID Equal exp .)
    RParen          reduce using rule 41 (binop -> GLOBID Equal exp .)
    COMMA           reduce using rule 41 (binop -> GLOBID Equal exp .)
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68

  ! Multiply        [ reduce using rule 41 (binop -> GLOBID Equal exp .) ]
  ! PLUS            [ reduce using rule 41 (binop -> GLOBID Equal exp .) ]
  ! Divide          [ reduce using rule 41 (binop -> GLOBID Equal exp .) ]
  ! Minus           [ reduce using rule 41 (binop -> GLOBID Equal exp .) ]
  ! Equality        [ reduce using rule 41 (binop -> GLOBID Equal exp .) ]
  ! Different       [ reduce using rule 41 (binop -> GLOBID Equal exp .) ]


state 92

    (25) Vector -> Array . LSquare RSquare
    (26) Vector -> Array . LSquare lit RSquare
    (27) Vector -> Array . LSquare GLOBID RSquare

    LSquare         shift and go to state 100


state 93

    (35) expWrapper -> LParen RParen .

    Semicolon       reduce using rule 35 (expWrapper -> LParen RParen .)
    Multiply        reduce using rule 35 (expWrapper -> LParen RParen .)
    PLUS            reduce using rule 35 (expWrapper -> LParen RParen .)
    Divide          reduce using rule 35 (expWrapper -> LParen RParen .)
    Minus           reduce using rule 35 (expWrapper -> LParen RParen .)
    Equality        reduce using rule 35 (expWrapper -> LParen RParen .)
    Different       reduce using rule 35 (expWrapper -> LParen RParen .)
    RParen          reduce using rule 35 (expWrapper -> LParen RParen .)
    COMMA           reduce using rule 35 (expWrapper -> LParen RParen .)


state 94

    (36) expWrapper -> LParen exps . RParen

    RParen          shift and go to state 101


state 95

    (28) exps -> exp .
    (29) exps -> exp . COMMA exps
    (37) binop -> exp . Multiply exp
    (38) binop -> exp . PLUS exp
    (39) binop -> exp . Divide exp
    (40) binop -> exp . Minus exp
    (42) binop -> exp . Equality exp
    (43) binop -> exp . Different exp

    RParen          reduce using rule 28 (exps -> exp .)
    COMMA           shift and go to state 102
    Multiply        shift and go to state 63
    PLUS            shift and go to state 64
    Divide          shift and go to state 65
    Minus           shift and go to state 66
    Equality        shift and go to state 67
    Different       shift and go to state 68


state 96

    (18) stmt -> vdecl Equal exp Semicolon .

    Return          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    While           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    If              reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Print           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    GLOBID          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LParen          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    lit             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    int             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    void            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    ref             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    noalias         reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    RBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Else            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)


state 97

    (20) stmt -> While LParen exp RParen . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (46) vdecl -> . TYPE GLOBID
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    GLOBID          shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 103
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 52

state 98

    (21) stmt -> If LParen exp RParen . stmt
    (22) stmt -> If LParen exp RParen . stmt Else stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (46) vdecl -> . TYPE GLOBID
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    GLOBID          shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 104
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 52

state 99

    (24) stmt -> GLOBID Equal Vector Semicolon .

    Return          reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    While           reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    If              reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    Print           reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    GLOBID          reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    LBracket        reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    LParen          reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    lit             reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    int             reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    void            reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    ref             reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    noalias         reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    RBracket        reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)
    Else            reduce using rule 24 (stmt -> GLOBID Equal Vector Semicolon .)


state 100

    (25) Vector -> Array LSquare . RSquare
    (26) Vector -> Array LSquare . lit RSquare
    (27) Vector -> Array LSquare . GLOBID RSquare

    RSquare         shift and go to state 105
    lit             shift and go to state 106
    GLOBID          shift and go to state 107


state 101

    (36) expWrapper -> LParen exps RParen .

    Semicolon       reduce using rule 36 (expWrapper -> LParen exps RParen .)
    Multiply        reduce using rule 36 (expWrapper -> LParen exps RParen .)
    PLUS            reduce using rule 36 (expWrapper -> LParen exps RParen .)
    Divide          reduce using rule 36 (expWrapper -> LParen exps RParen .)
    Minus           reduce using rule 36 (expWrapper -> LParen exps RParen .)
    Equality        reduce using rule 36 (expWrapper -> LParen exps RParen .)
    Different       reduce using rule 36 (expWrapper -> LParen exps RParen .)
    RParen          reduce using rule 36 (expWrapper -> LParen exps RParen .)
    COMMA           reduce using rule 36 (expWrapper -> LParen exps RParen .)


state 102

    (29) exps -> exp COMMA . exps
    (28) exps -> . exp
    (29) exps -> . exp COMMA exps
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 61

    exp                            shift and go to state 95
    exps                           shift and go to state 108
    binop                          shift and go to state 52

state 103

    (20) stmt -> While LParen exp RParen stmt .

    Return          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    While           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    If              reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Print           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    GLOBID          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LParen          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    lit             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    int             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    void            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    ref             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    noalias         reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    RBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Else            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)


state 104

    (21) stmt -> If LParen exp RParen stmt .
    (22) stmt -> If LParen exp RParen stmt . Else stmt

  ! shift/reduce conflict for Else resolved as shift
    Return          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    While           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    If              reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Print           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    GLOBID          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LParen          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    lit             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    int             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    void            reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    ref             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    noalias         reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    RBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Else            shift and go to state 109

  ! Else            [ reduce using rule 21 (stmt -> If LParen exp RParen stmt .) ]


state 105

    (25) Vector -> Array LSquare RSquare .

    Semicolon       reduce using rule 25 (Vector -> Array LSquare RSquare .)


state 106

    (26) Vector -> Array LSquare lit . RSquare

    RSquare         shift and go to state 110


state 107

    (27) Vector -> Array LSquare GLOBID . RSquare

    RSquare         shift and go to state 111


state 108

    (29) exps -> exp COMMA exps .

    RParen          reduce using rule 29 (exps -> exp COMMA exps .)


state 109

    (22) stmt -> If LParen exp RParen stmt Else . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (46) vdecl -> . TYPE GLOBID
    (30) exp -> . LParen exp RParen
    (31) exp -> . lit
    (32) exp -> . binop
    (33) exp -> . GLOBID
    (34) exp -> . GLOBID expWrapper
    (49) TYPE -> . int
    (50) TYPE -> . void
    (51) TYPE -> . ref TYPE
    (52) TYPE -> . noalias ref TYPE
    (37) binop -> . exp Multiply exp
    (38) binop -> . exp PLUS exp
    (39) binop -> . exp Divide exp
    (40) binop -> . exp Minus exp
    (41) binop -> . GLOBID Equal exp
    (42) binop -> . exp Equality exp
    (43) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    GLOBID          shift and go to state 50
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 112
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 52

state 110

    (26) Vector -> Array LSquare lit RSquare .

    Semicolon       reduce using rule 26 (Vector -> Array LSquare lit RSquare .)


state 111

    (27) Vector -> Array LSquare GLOBID RSquare .

    Semicolon       reduce using rule 27 (Vector -> Array LSquare GLOBID RSquare .)


state 112

    (22) stmt -> If LParen exp RParen stmt Else stmt .

    Return          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    While           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    If              reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Print           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    GLOBID          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LParen          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    lit             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    int             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    void            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    ref             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    noalias         reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    RBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Else            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for Else in state 104 resolved as shift
