Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> prog
Rule 1     prog -> funcs
Rule 2     prog -> externs funcs
Rule 3     externs -> extern
Rule 4     externs -> extern externs
Rule 5     funcs -> func
Rule 6     funcs -> func funcs
Rule 7     extern -> EXTERN TYPE GLOBID LParen RParen Semicolon
Rule 8     extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon
Rule 9     func -> DEF TYPE GLOBID LParen RParen blk
Rule 10    func -> DEF TYPE GLOBID LParen vdecls RParen blk
Rule 11    blk -> LBracket stmts RBracket
Rule 12    blk -> LBracket RBracket
Rule 13    stmts -> stmt
Rule 14    stmts -> stmt stmts
Rule 15    stmt -> blk
Rule 16    stmt -> Return Semicolon
Rule 17    stmt -> Return exp Semicolon
Rule 18    stmt -> vdecl Equal exp Semicolon
Rule 19    stmt -> exp Semicolon
Rule 20    stmt -> While LParen exp RParen stmt
Rule 21    stmt -> If LParen exp RParen stmt
Rule 22    stmt -> If LParen exp RParen stmt Else stmt
Rule 23    stmt -> Print exp Semicolon
Rule 24    stmt -> Array LSquare lit RSquare PLUS lit Semicolon
Rule 25    stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon
Rule 26    stmt -> Array LSquare lit RSquare Minus lit Semicolon
Rule 27    stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon
Rule 28    stmt -> GLOBID Equal Vector Semicolon
Rule 29    Vector -> Array LSquare RSquare
Rule 30    Vector -> Array LSquare lit RSquare
Rule 31    Vector -> Array LSquare GLOBID RSquare
Rule 32    exps -> exp
Rule 33    exps -> exp COMMA exps
Rule 34    exp -> LParen exp RParen
Rule 35    exp -> lit
Rule 36    exp -> binop
Rule 37    exp -> GLOBID
Rule 38    exp -> GLOBID expWrapper
Rule 39    expWrapper -> LParen RParen
Rule 40    expWrapper -> LParen exps RParen
Rule 41    binop -> exp Multiply exp
Rule 42    binop -> exp PLUS exp
Rule 43    binop -> exp Divide exp
Rule 44    binop -> exp Minus exp
Rule 45    binop -> GLOBID Equal exp
Rule 46    binop -> exp Equality exp
Rule 47    binop -> exp Different exp
Rule 48    vdecls -> vdecl COMMA vdecls
Rule 49    vdecls -> vdecl
Rule 50    vdecl -> TYPE GLOBID
Rule 51    tdecls -> TYPE
Rule 52    tdecls -> TYPE COMMA tdecls
Rule 53    TYPE -> int
Rule 54    TYPE -> void
Rule 55    TYPE -> ref TYPE
Rule 56    TYPE -> noalias ref TYPE

Terminals, with rules where they appear

Array                : 24 25 26 27 29 30 31
COMMA                : 33 48 52
DEF                  : 9 10
Different            : 47
Divide               : 43
EXTERN               : 7 8
Else                 : 22
Equal                : 18 28 45
Equality             : 46
GLOBID               : 7 8 9 10 25 27 28 31 37 38 45 50
If                   : 21 22
LBracket             : 11 12
LParen               : 7 8 9 10 20 21 22 34 39 40
LSquare              : 24 25 26 27 29 30 31
Minus                : 26 27 44
Multiply             : 41
PLUS                 : 24 25 42
Print                : 23
RBracket             : 11 12
RParen               : 7 8 9 10 20 21 22 34 39 40
RSquare              : 24 25 26 27 29 30 31
Return               : 16 17
Semicolon            : 7 8 16 17 18 19 23 24 25 26 27 28
While                : 20
error                : 
int                  : 53
lit                  : 24 24 25 26 26 27 30 35
noalias              : 56
ref                  : 55 56
void                 : 54

Nonterminals, with rules where they appear

TYPE                 : 7 8 9 10 50 51 52 55 56
Vector               : 28
binop                : 36
blk                  : 9 10 15
exp                  : 17 18 19 20 21 22 23 32 33 34 41 41 42 42 43 43 44 44 45 46 46 47 47
expWrapper           : 38
exps                 : 33 40
extern               : 3 4
externs              : 2 4
func                 : 5 6
funcs                : 1 2 6
prog                 : 0
stmt                 : 13 14 20 21 22 22
stmts                : 11 14
tdecls               : 8 52
vdecl                : 18 48 49
vdecls               : 10 48

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . funcs
    (2) prog -> . externs funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             shift and go to state 6
    EXTERN          shift and go to state 7

    prog                           shift and go to state 1
    funcs                          shift and go to state 2
    externs                        shift and go to state 3
    func                           shift and go to state 4
    extern                         shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> funcs .

    $end            reduce using rule 1 (prog -> funcs .)


state 3

    (2) prog -> externs . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    DEF             shift and go to state 6

    funcs                          shift and go to state 8
    func                           shift and go to state 4

state 4

    (5) funcs -> func .
    (6) funcs -> func . funcs
    (5) funcs -> . func
    (6) funcs -> . func funcs
    (9) func -> . DEF TYPE GLOBID LParen RParen blk
    (10) func -> . DEF TYPE GLOBID LParen vdecls RParen blk

    $end            reduce using rule 5 (funcs -> func .)
    DEF             shift and go to state 6

    func                           shift and go to state 4
    funcs                          shift and go to state 9

state 5

    (3) externs -> extern .
    (4) externs -> extern . externs
    (3) externs -> . extern
    (4) externs -> . extern externs
    (7) extern -> . EXTERN TYPE GLOBID LParen RParen Semicolon
    (8) extern -> . EXTERN TYPE GLOBID LParen tdecls RParen Semicolon

    DEF             reduce using rule 3 (externs -> extern .)
    EXTERN          shift and go to state 7

    extern                         shift and go to state 5
    externs                        shift and go to state 10

state 6

    (9) func -> DEF . TYPE GLOBID LParen RParen blk
    (10) func -> DEF . TYPE GLOBID LParen vdecls RParen blk
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 11

state 7

    (7) extern -> EXTERN . TYPE GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN . TYPE GLOBID LParen tdecls RParen Semicolon
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 16

state 8

    (2) prog -> externs funcs .

    $end            reduce using rule 2 (prog -> externs funcs .)


state 9

    (6) funcs -> func funcs .

    $end            reduce using rule 6 (funcs -> func funcs .)


state 10

    (4) externs -> extern externs .

    DEF             reduce using rule 4 (externs -> extern externs .)


state 11

    (9) func -> DEF TYPE . GLOBID LParen RParen blk
    (10) func -> DEF TYPE . GLOBID LParen vdecls RParen blk

    GLOBID          shift and go to state 17


state 12

    (53) TYPE -> int .

    GLOBID          reduce using rule 53 (TYPE -> int .)
    COMMA           reduce using rule 53 (TYPE -> int .)
    RParen          reduce using rule 53 (TYPE -> int .)


state 13

    (54) TYPE -> void .

    GLOBID          reduce using rule 54 (TYPE -> void .)
    COMMA           reduce using rule 54 (TYPE -> void .)
    RParen          reduce using rule 54 (TYPE -> void .)


state 14

    (55) TYPE -> ref . TYPE
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 18

state 15

    (56) TYPE -> noalias . ref TYPE

    ref             shift and go to state 19


state 16

    (7) extern -> EXTERN TYPE . GLOBID LParen RParen Semicolon
    (8) extern -> EXTERN TYPE . GLOBID LParen tdecls RParen Semicolon

    GLOBID          shift and go to state 20


state 17

    (9) func -> DEF TYPE GLOBID . LParen RParen blk
    (10) func -> DEF TYPE GLOBID . LParen vdecls RParen blk

    LParen          shift and go to state 21


state 18

    (55) TYPE -> ref TYPE .

    GLOBID          reduce using rule 55 (TYPE -> ref TYPE .)
    COMMA           reduce using rule 55 (TYPE -> ref TYPE .)
    RParen          reduce using rule 55 (TYPE -> ref TYPE .)


state 19

    (56) TYPE -> noalias ref . TYPE
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 22

state 20

    (7) extern -> EXTERN TYPE GLOBID . LParen RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID . LParen tdecls RParen Semicolon

    LParen          shift and go to state 23


state 21

    (9) func -> DEF TYPE GLOBID LParen . RParen blk
    (10) func -> DEF TYPE GLOBID LParen . vdecls RParen blk
    (48) vdecls -> . vdecl COMMA vdecls
    (49) vdecls -> . vdecl
    (50) vdecl -> . TYPE GLOBID
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 25
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 24
    vdecls                         shift and go to state 26
    vdecl                          shift and go to state 27

state 22

    (56) TYPE -> noalias ref TYPE .

    GLOBID          reduce using rule 56 (TYPE -> noalias ref TYPE .)
    COMMA           reduce using rule 56 (TYPE -> noalias ref TYPE .)
    RParen          reduce using rule 56 (TYPE -> noalias ref TYPE .)


state 23

    (7) extern -> EXTERN TYPE GLOBID LParen . RParen Semicolon
    (8) extern -> EXTERN TYPE GLOBID LParen . tdecls RParen Semicolon
    (51) tdecls -> . TYPE
    (52) tdecls -> . TYPE COMMA tdecls
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    RParen          shift and go to state 29
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 28
    tdecls                         shift and go to state 30

state 24

    (50) vdecl -> TYPE . GLOBID

    GLOBID          shift and go to state 31


state 25

    (9) func -> DEF TYPE GLOBID LParen RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 33

    blk                            shift and go to state 32

state 26

    (10) func -> DEF TYPE GLOBID LParen vdecls . RParen blk

    RParen          shift and go to state 34


state 27

    (48) vdecls -> vdecl . COMMA vdecls
    (49) vdecls -> vdecl .

    COMMA           shift and go to state 35
    RParen          reduce using rule 49 (vdecls -> vdecl .)


state 28

    (51) tdecls -> TYPE .
    (52) tdecls -> TYPE . COMMA tdecls

    RParen          reduce using rule 51 (tdecls -> TYPE .)
    COMMA           shift and go to state 36


state 29

    (7) extern -> EXTERN TYPE GLOBID LParen RParen . Semicolon

    Semicolon       shift and go to state 37


state 30

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls . RParen Semicolon

    RParen          shift and go to state 38


state 31

    (50) vdecl -> TYPE GLOBID .

    COMMA           reduce using rule 50 (vdecl -> TYPE GLOBID .)
    RParen          reduce using rule 50 (vdecl -> TYPE GLOBID .)
    Equal           reduce using rule 50 (vdecl -> TYPE GLOBID .)


state 32

    (9) func -> DEF TYPE GLOBID LParen RParen blk .

    DEF             reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)
    $end            reduce using rule 9 (func -> DEF TYPE GLOBID LParen RParen blk .)


state 33

    (11) blk -> LBracket . stmts RBracket
    (12) blk -> LBracket . RBracket
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare PLUS lit Semicolon
    (25) stmt -> . Array LSquare GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> . Array LSquare lit RSquare Minus lit Semicolon
    (27) stmt -> . Array LSquare GLOBID RSquare Minus lit Semicolon
    (28) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (50) vdecl -> . TYPE GLOBID
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    RBracket        shift and go to state 40
    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    GLOBID          shift and go to state 52
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    stmts                          shift and go to state 39
    stmt                           shift and go to state 41
    blk                            shift and go to state 42
    exp                            shift and go to state 44
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 34

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen . blk
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket

    LBracket        shift and go to state 33

    blk                            shift and go to state 54

state 35

    (48) vdecls -> vdecl COMMA . vdecls
    (48) vdecls -> . vdecl COMMA vdecls
    (49) vdecls -> . vdecl
    (50) vdecl -> . TYPE GLOBID
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    vdecl                          shift and go to state 27
    vdecls                         shift and go to state 55
    TYPE                           shift and go to state 24

state 36

    (52) tdecls -> TYPE COMMA . tdecls
    (51) tdecls -> . TYPE
    (52) tdecls -> . TYPE COMMA tdecls
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE

    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    TYPE                           shift and go to state 28
    tdecls                         shift and go to state 56

state 37

    (7) extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .

    EXTERN          reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)
    DEF             reduce using rule 7 (extern -> EXTERN TYPE GLOBID LParen RParen Semicolon .)


state 38

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen . Semicolon

    Semicolon       shift and go to state 57


state 39

    (11) blk -> LBracket stmts . RBracket

    RBracket        shift and go to state 58


state 40

    (12) blk -> LBracket RBracket .

    DEF             reduce using rule 12 (blk -> LBracket RBracket .)
    $end            reduce using rule 12 (blk -> LBracket RBracket .)
    Return          reduce using rule 12 (blk -> LBracket RBracket .)
    While           reduce using rule 12 (blk -> LBracket RBracket .)
    If              reduce using rule 12 (blk -> LBracket RBracket .)
    Print           reduce using rule 12 (blk -> LBracket RBracket .)
    Array           reduce using rule 12 (blk -> LBracket RBracket .)
    GLOBID          reduce using rule 12 (blk -> LBracket RBracket .)
    LBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    LParen          reduce using rule 12 (blk -> LBracket RBracket .)
    lit             reduce using rule 12 (blk -> LBracket RBracket .)
    int             reduce using rule 12 (blk -> LBracket RBracket .)
    void            reduce using rule 12 (blk -> LBracket RBracket .)
    ref             reduce using rule 12 (blk -> LBracket RBracket .)
    noalias         reduce using rule 12 (blk -> LBracket RBracket .)
    RBracket        reduce using rule 12 (blk -> LBracket RBracket .)
    Else            reduce using rule 12 (blk -> LBracket RBracket .)


state 41

    (13) stmts -> stmt .
    (14) stmts -> stmt . stmts
    (13) stmts -> . stmt
    (14) stmts -> . stmt stmts
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare PLUS lit Semicolon
    (25) stmt -> . Array LSquare GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> . Array LSquare lit RSquare Minus lit Semicolon
    (27) stmt -> . Array LSquare GLOBID RSquare Minus lit Semicolon
    (28) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (50) vdecl -> . TYPE GLOBID
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    RBracket        reduce using rule 13 (stmts -> stmt .)
    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    GLOBID          shift and go to state 52
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    stmt                           shift and go to state 41
    stmts                          shift and go to state 59
    blk                            shift and go to state 42
    exp                            shift and go to state 44
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 42

    (15) stmt -> blk .

    Return          reduce using rule 15 (stmt -> blk .)
    While           reduce using rule 15 (stmt -> blk .)
    If              reduce using rule 15 (stmt -> blk .)
    Print           reduce using rule 15 (stmt -> blk .)
    Array           reduce using rule 15 (stmt -> blk .)
    GLOBID          reduce using rule 15 (stmt -> blk .)
    LBracket        reduce using rule 15 (stmt -> blk .)
    LParen          reduce using rule 15 (stmt -> blk .)
    lit             reduce using rule 15 (stmt -> blk .)
    int             reduce using rule 15 (stmt -> blk .)
    void            reduce using rule 15 (stmt -> blk .)
    ref             reduce using rule 15 (stmt -> blk .)
    noalias         reduce using rule 15 (stmt -> blk .)
    RBracket        reduce using rule 15 (stmt -> blk .)
    Else            reduce using rule 15 (stmt -> blk .)


state 43

    (16) stmt -> Return . Semicolon
    (17) stmt -> Return . exp Semicolon
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    Semicolon       shift and go to state 60
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 61
    binop                          shift and go to state 53

state 44

    (19) stmt -> exp . Semicolon
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       shift and go to state 63
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 45

    (18) stmt -> vdecl . Equal exp Semicolon

    Equal           shift and go to state 70


state 46

    (20) stmt -> While . LParen exp RParen stmt

    LParen          shift and go to state 71


state 47

    (34) exp -> LParen . exp RParen
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 72
    binop                          shift and go to state 53

state 48

    (21) stmt -> If . LParen exp RParen stmt
    (22) stmt -> If . LParen exp RParen stmt Else stmt

    LParen          shift and go to state 73


state 49

    (23) stmt -> Print . exp Semicolon
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 74
    binop                          shift and go to state 53

state 50

    (24) stmt -> Array . LSquare lit RSquare PLUS lit Semicolon
    (25) stmt -> Array . LSquare GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> Array . LSquare lit RSquare Minus lit Semicolon
    (27) stmt -> Array . LSquare GLOBID RSquare Minus lit Semicolon

    LSquare         shift and go to state 75


state 51

    (35) exp -> lit .

    Semicolon       reduce using rule 35 (exp -> lit .)
    Multiply        reduce using rule 35 (exp -> lit .)
    PLUS            reduce using rule 35 (exp -> lit .)
    Divide          reduce using rule 35 (exp -> lit .)
    Minus           reduce using rule 35 (exp -> lit .)
    Equality        reduce using rule 35 (exp -> lit .)
    Different       reduce using rule 35 (exp -> lit .)
    RParen          reduce using rule 35 (exp -> lit .)
    COMMA           reduce using rule 35 (exp -> lit .)


state 52

    (28) stmt -> GLOBID . Equal Vector Semicolon
    (37) exp -> GLOBID .
    (38) exp -> GLOBID . expWrapper
    (45) binop -> GLOBID . Equal exp
    (39) expWrapper -> . LParen RParen
    (40) expWrapper -> . LParen exps RParen

    Equal           shift and go to state 76
    Semicolon       reduce using rule 37 (exp -> GLOBID .)
    Multiply        reduce using rule 37 (exp -> GLOBID .)
    PLUS            reduce using rule 37 (exp -> GLOBID .)
    Divide          reduce using rule 37 (exp -> GLOBID .)
    Minus           reduce using rule 37 (exp -> GLOBID .)
    Equality        reduce using rule 37 (exp -> GLOBID .)
    Different       reduce using rule 37 (exp -> GLOBID .)
    LParen          shift and go to state 78

    expWrapper                     shift and go to state 77

state 53

    (36) exp -> binop .

    Semicolon       reduce using rule 36 (exp -> binop .)
    Multiply        reduce using rule 36 (exp -> binop .)
    PLUS            reduce using rule 36 (exp -> binop .)
    Divide          reduce using rule 36 (exp -> binop .)
    Minus           reduce using rule 36 (exp -> binop .)
    Equality        reduce using rule 36 (exp -> binop .)
    Different       reduce using rule 36 (exp -> binop .)
    RParen          reduce using rule 36 (exp -> binop .)
    COMMA           reduce using rule 36 (exp -> binop .)


state 54

    (10) func -> DEF TYPE GLOBID LParen vdecls RParen blk .

    DEF             reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)
    $end            reduce using rule 10 (func -> DEF TYPE GLOBID LParen vdecls RParen blk .)


state 55

    (48) vdecls -> vdecl COMMA vdecls .

    RParen          reduce using rule 48 (vdecls -> vdecl COMMA vdecls .)


state 56

    (52) tdecls -> TYPE COMMA tdecls .

    RParen          reduce using rule 52 (tdecls -> TYPE COMMA tdecls .)


state 57

    (8) extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .

    EXTERN          reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)
    DEF             reduce using rule 8 (extern -> EXTERN TYPE GLOBID LParen tdecls RParen Semicolon .)


state 58

    (11) blk -> LBracket stmts RBracket .

    DEF             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    $end            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Return          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    While           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    If              reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Print           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Array           reduce using rule 11 (blk -> LBracket stmts RBracket .)
    GLOBID          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    LParen          reduce using rule 11 (blk -> LBracket stmts RBracket .)
    lit             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    int             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    void            reduce using rule 11 (blk -> LBracket stmts RBracket .)
    ref             reduce using rule 11 (blk -> LBracket stmts RBracket .)
    noalias         reduce using rule 11 (blk -> LBracket stmts RBracket .)
    RBracket        reduce using rule 11 (blk -> LBracket stmts RBracket .)
    Else            reduce using rule 11 (blk -> LBracket stmts RBracket .)


state 59

    (14) stmts -> stmt stmts .

    RBracket        reduce using rule 14 (stmts -> stmt stmts .)


state 60

    (16) stmt -> Return Semicolon .

    Return          reduce using rule 16 (stmt -> Return Semicolon .)
    While           reduce using rule 16 (stmt -> Return Semicolon .)
    If              reduce using rule 16 (stmt -> Return Semicolon .)
    Print           reduce using rule 16 (stmt -> Return Semicolon .)
    Array           reduce using rule 16 (stmt -> Return Semicolon .)
    GLOBID          reduce using rule 16 (stmt -> Return Semicolon .)
    LBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    LParen          reduce using rule 16 (stmt -> Return Semicolon .)
    lit             reduce using rule 16 (stmt -> Return Semicolon .)
    int             reduce using rule 16 (stmt -> Return Semicolon .)
    void            reduce using rule 16 (stmt -> Return Semicolon .)
    ref             reduce using rule 16 (stmt -> Return Semicolon .)
    noalias         reduce using rule 16 (stmt -> Return Semicolon .)
    RBracket        reduce using rule 16 (stmt -> Return Semicolon .)
    Else            reduce using rule 16 (stmt -> Return Semicolon .)


state 61

    (17) stmt -> Return exp . Semicolon
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       shift and go to state 79
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 62

    (37) exp -> GLOBID .
    (38) exp -> GLOBID . expWrapper
    (45) binop -> GLOBID . Equal exp
    (39) expWrapper -> . LParen RParen
    (40) expWrapper -> . LParen exps RParen

    Semicolon       reduce using rule 37 (exp -> GLOBID .)
    Multiply        reduce using rule 37 (exp -> GLOBID .)
    PLUS            reduce using rule 37 (exp -> GLOBID .)
    Divide          reduce using rule 37 (exp -> GLOBID .)
    Minus           reduce using rule 37 (exp -> GLOBID .)
    Equality        reduce using rule 37 (exp -> GLOBID .)
    Different       reduce using rule 37 (exp -> GLOBID .)
    RParen          reduce using rule 37 (exp -> GLOBID .)
    COMMA           reduce using rule 37 (exp -> GLOBID .)
    Equal           shift and go to state 80
    LParen          shift and go to state 78

    expWrapper                     shift and go to state 77

state 63

    (19) stmt -> exp Semicolon .

    Return          reduce using rule 19 (stmt -> exp Semicolon .)
    While           reduce using rule 19 (stmt -> exp Semicolon .)
    If              reduce using rule 19 (stmt -> exp Semicolon .)
    Print           reduce using rule 19 (stmt -> exp Semicolon .)
    Array           reduce using rule 19 (stmt -> exp Semicolon .)
    GLOBID          reduce using rule 19 (stmt -> exp Semicolon .)
    LBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    LParen          reduce using rule 19 (stmt -> exp Semicolon .)
    lit             reduce using rule 19 (stmt -> exp Semicolon .)
    int             reduce using rule 19 (stmt -> exp Semicolon .)
    void            reduce using rule 19 (stmt -> exp Semicolon .)
    ref             reduce using rule 19 (stmt -> exp Semicolon .)
    noalias         reduce using rule 19 (stmt -> exp Semicolon .)
    RBracket        reduce using rule 19 (stmt -> exp Semicolon .)
    Else            reduce using rule 19 (stmt -> exp Semicolon .)


state 64

    (41) binop -> exp Multiply . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 81
    binop                          shift and go to state 53

state 65

    (42) binop -> exp PLUS . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 82
    binop                          shift and go to state 53

state 66

    (43) binop -> exp Divide . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 83
    binop                          shift and go to state 53

state 67

    (44) binop -> exp Minus . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 84
    binop                          shift and go to state 53

state 68

    (46) binop -> exp Equality . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 85
    binop                          shift and go to state 53

state 69

    (47) binop -> exp Different . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 86
    binop                          shift and go to state 53

state 70

    (18) stmt -> vdecl Equal . exp Semicolon
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 87
    binop                          shift and go to state 53

state 71

    (20) stmt -> While LParen . exp RParen stmt
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 88
    binop                          shift and go to state 53

state 72

    (34) exp -> LParen exp . RParen
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    RParen          shift and go to state 89
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 73

    (21) stmt -> If LParen . exp RParen stmt
    (22) stmt -> If LParen . exp RParen stmt Else stmt
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 90
    binop                          shift and go to state 53

state 74

    (23) stmt -> Print exp . Semicolon
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       shift and go to state 91
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 75

    (24) stmt -> Array LSquare . lit RSquare PLUS lit Semicolon
    (25) stmt -> Array LSquare . GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> Array LSquare . lit RSquare Minus lit Semicolon
    (27) stmt -> Array LSquare . GLOBID RSquare Minus lit Semicolon

    lit             shift and go to state 92
    GLOBID          shift and go to state 93


state 76

    (28) stmt -> GLOBID Equal . Vector Semicolon
    (45) binop -> GLOBID Equal . exp
    (29) Vector -> . Array LSquare RSquare
    (30) Vector -> . Array LSquare lit RSquare
    (31) Vector -> . Array LSquare GLOBID RSquare
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    Array           shift and go to state 96
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    Vector                         shift and go to state 94
    exp                            shift and go to state 95
    binop                          shift and go to state 53

state 77

    (38) exp -> GLOBID expWrapper .

    Semicolon       reduce using rule 38 (exp -> GLOBID expWrapper .)
    Multiply        reduce using rule 38 (exp -> GLOBID expWrapper .)
    PLUS            reduce using rule 38 (exp -> GLOBID expWrapper .)
    Divide          reduce using rule 38 (exp -> GLOBID expWrapper .)
    Minus           reduce using rule 38 (exp -> GLOBID expWrapper .)
    Equality        reduce using rule 38 (exp -> GLOBID expWrapper .)
    Different       reduce using rule 38 (exp -> GLOBID expWrapper .)
    RParen          reduce using rule 38 (exp -> GLOBID expWrapper .)
    COMMA           reduce using rule 38 (exp -> GLOBID expWrapper .)


state 78

    (39) expWrapper -> LParen . RParen
    (40) expWrapper -> LParen . exps RParen
    (32) exps -> . exp
    (33) exps -> . exp COMMA exps
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    RParen          shift and go to state 97
    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exps                           shift and go to state 98
    exp                            shift and go to state 99
    binop                          shift and go to state 53

state 79

    (17) stmt -> Return exp Semicolon .

    Return          reduce using rule 17 (stmt -> Return exp Semicolon .)
    While           reduce using rule 17 (stmt -> Return exp Semicolon .)
    If              reduce using rule 17 (stmt -> Return exp Semicolon .)
    Print           reduce using rule 17 (stmt -> Return exp Semicolon .)
    Array           reduce using rule 17 (stmt -> Return exp Semicolon .)
    GLOBID          reduce using rule 17 (stmt -> Return exp Semicolon .)
    LBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    LParen          reduce using rule 17 (stmt -> Return exp Semicolon .)
    lit             reduce using rule 17 (stmt -> Return exp Semicolon .)
    int             reduce using rule 17 (stmt -> Return exp Semicolon .)
    void            reduce using rule 17 (stmt -> Return exp Semicolon .)
    ref             reduce using rule 17 (stmt -> Return exp Semicolon .)
    noalias         reduce using rule 17 (stmt -> Return exp Semicolon .)
    RBracket        reduce using rule 17 (stmt -> Return exp Semicolon .)
    Else            reduce using rule 17 (stmt -> Return exp Semicolon .)


state 80

    (45) binop -> GLOBID Equal . exp
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 95
    binop                          shift and go to state 53

state 81

    (41) binop -> exp Multiply exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 41 (binop -> exp Multiply exp .)
    Multiply        reduce using rule 41 (binop -> exp Multiply exp .)
    PLUS            reduce using rule 41 (binop -> exp Multiply exp .)
    Divide          reduce using rule 41 (binop -> exp Multiply exp .)
    Minus           reduce using rule 41 (binop -> exp Multiply exp .)
    Equality        reduce using rule 41 (binop -> exp Multiply exp .)
    Different       reduce using rule 41 (binop -> exp Multiply exp .)
    RParen          reduce using rule 41 (binop -> exp Multiply exp .)
    COMMA           reduce using rule 41 (binop -> exp Multiply exp .)

  ! Multiply        [ shift and go to state 64 ]
  ! PLUS            [ shift and go to state 65 ]
  ! Divide          [ shift and go to state 66 ]
  ! Minus           [ shift and go to state 67 ]
  ! Equality        [ shift and go to state 68 ]
  ! Different       [ shift and go to state 69 ]


state 82

    (42) binop -> exp PLUS exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 42 (binop -> exp PLUS exp .)
    PLUS            reduce using rule 42 (binop -> exp PLUS exp .)
    Minus           reduce using rule 42 (binop -> exp PLUS exp .)
    Equality        reduce using rule 42 (binop -> exp PLUS exp .)
    Different       reduce using rule 42 (binop -> exp PLUS exp .)
    RParen          reduce using rule 42 (binop -> exp PLUS exp .)
    COMMA           reduce using rule 42 (binop -> exp PLUS exp .)
    Multiply        shift and go to state 64
    Divide          shift and go to state 66

  ! Multiply        [ reduce using rule 42 (binop -> exp PLUS exp .) ]
  ! Divide          [ reduce using rule 42 (binop -> exp PLUS exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! Minus           [ shift and go to state 67 ]
  ! Equality        [ shift and go to state 68 ]
  ! Different       [ shift and go to state 69 ]


state 83

    (43) binop -> exp Divide exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 43 (binop -> exp Divide exp .)
    Multiply        reduce using rule 43 (binop -> exp Divide exp .)
    PLUS            reduce using rule 43 (binop -> exp Divide exp .)
    Divide          reduce using rule 43 (binop -> exp Divide exp .)
    Minus           reduce using rule 43 (binop -> exp Divide exp .)
    Equality        reduce using rule 43 (binop -> exp Divide exp .)
    Different       reduce using rule 43 (binop -> exp Divide exp .)
    RParen          reduce using rule 43 (binop -> exp Divide exp .)
    COMMA           reduce using rule 43 (binop -> exp Divide exp .)

  ! Multiply        [ shift and go to state 64 ]
  ! PLUS            [ shift and go to state 65 ]
  ! Divide          [ shift and go to state 66 ]
  ! Minus           [ shift and go to state 67 ]
  ! Equality        [ shift and go to state 68 ]
  ! Different       [ shift and go to state 69 ]


state 84

    (44) binop -> exp Minus exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 44 (binop -> exp Minus exp .)
    PLUS            reduce using rule 44 (binop -> exp Minus exp .)
    Minus           reduce using rule 44 (binop -> exp Minus exp .)
    Equality        reduce using rule 44 (binop -> exp Minus exp .)
    Different       reduce using rule 44 (binop -> exp Minus exp .)
    RParen          reduce using rule 44 (binop -> exp Minus exp .)
    COMMA           reduce using rule 44 (binop -> exp Minus exp .)
    Multiply        shift and go to state 64
    Divide          shift and go to state 66

  ! Multiply        [ reduce using rule 44 (binop -> exp Minus exp .) ]
  ! Divide          [ reduce using rule 44 (binop -> exp Minus exp .) ]
  ! PLUS            [ shift and go to state 65 ]
  ! Minus           [ shift and go to state 67 ]
  ! Equality        [ shift and go to state 68 ]
  ! Different       [ shift and go to state 69 ]


state 85

    (46) binop -> exp Equality exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 46 (binop -> exp Equality exp .)
    Equality        reduce using rule 46 (binop -> exp Equality exp .)
    Different       reduce using rule 46 (binop -> exp Equality exp .)
    RParen          reduce using rule 46 (binop -> exp Equality exp .)
    COMMA           reduce using rule 46 (binop -> exp Equality exp .)
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67

  ! Multiply        [ reduce using rule 46 (binop -> exp Equality exp .) ]
  ! PLUS            [ reduce using rule 46 (binop -> exp Equality exp .) ]
  ! Divide          [ reduce using rule 46 (binop -> exp Equality exp .) ]
  ! Minus           [ reduce using rule 46 (binop -> exp Equality exp .) ]
  ! Equality        [ shift and go to state 68 ]
  ! Different       [ shift and go to state 69 ]


state 86

    (47) binop -> exp Different exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 47 (binop -> exp Different exp .)
    Equality        reduce using rule 47 (binop -> exp Different exp .)
    Different       reduce using rule 47 (binop -> exp Different exp .)
    RParen          reduce using rule 47 (binop -> exp Different exp .)
    COMMA           reduce using rule 47 (binop -> exp Different exp .)
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67

  ! Multiply        [ reduce using rule 47 (binop -> exp Different exp .) ]
  ! PLUS            [ reduce using rule 47 (binop -> exp Different exp .) ]
  ! Divide          [ reduce using rule 47 (binop -> exp Different exp .) ]
  ! Minus           [ reduce using rule 47 (binop -> exp Different exp .) ]
  ! Equality        [ shift and go to state 68 ]
  ! Different       [ shift and go to state 69 ]


state 87

    (18) stmt -> vdecl Equal exp . Semicolon
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       shift and go to state 100
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 88

    (20) stmt -> While LParen exp . RParen stmt
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    RParen          shift and go to state 101
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 89

    (34) exp -> LParen exp RParen .

    Semicolon       reduce using rule 34 (exp -> LParen exp RParen .)
    Multiply        reduce using rule 34 (exp -> LParen exp RParen .)
    PLUS            reduce using rule 34 (exp -> LParen exp RParen .)
    Divide          reduce using rule 34 (exp -> LParen exp RParen .)
    Minus           reduce using rule 34 (exp -> LParen exp RParen .)
    Equality        reduce using rule 34 (exp -> LParen exp RParen .)
    Different       reduce using rule 34 (exp -> LParen exp RParen .)
    RParen          reduce using rule 34 (exp -> LParen exp RParen .)
    COMMA           reduce using rule 34 (exp -> LParen exp RParen .)


state 90

    (21) stmt -> If LParen exp . RParen stmt
    (22) stmt -> If LParen exp . RParen stmt Else stmt
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    RParen          shift and go to state 102
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 91

    (23) stmt -> Print exp Semicolon .

    Return          reduce using rule 23 (stmt -> Print exp Semicolon .)
    While           reduce using rule 23 (stmt -> Print exp Semicolon .)
    If              reduce using rule 23 (stmt -> Print exp Semicolon .)
    Print           reduce using rule 23 (stmt -> Print exp Semicolon .)
    Array           reduce using rule 23 (stmt -> Print exp Semicolon .)
    GLOBID          reduce using rule 23 (stmt -> Print exp Semicolon .)
    LBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    LParen          reduce using rule 23 (stmt -> Print exp Semicolon .)
    lit             reduce using rule 23 (stmt -> Print exp Semicolon .)
    int             reduce using rule 23 (stmt -> Print exp Semicolon .)
    void            reduce using rule 23 (stmt -> Print exp Semicolon .)
    ref             reduce using rule 23 (stmt -> Print exp Semicolon .)
    noalias         reduce using rule 23 (stmt -> Print exp Semicolon .)
    RBracket        reduce using rule 23 (stmt -> Print exp Semicolon .)
    Else            reduce using rule 23 (stmt -> Print exp Semicolon .)


state 92

    (24) stmt -> Array LSquare lit . RSquare PLUS lit Semicolon
    (26) stmt -> Array LSquare lit . RSquare Minus lit Semicolon

    RSquare         shift and go to state 103


state 93

    (25) stmt -> Array LSquare GLOBID . RSquare PLUS lit Semicolon
    (27) stmt -> Array LSquare GLOBID . RSquare Minus lit Semicolon

    RSquare         shift and go to state 104


state 94

    (28) stmt -> GLOBID Equal Vector . Semicolon

    Semicolon       shift and go to state 105


state 95

    (45) binop -> GLOBID Equal exp .
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    Semicolon       reduce using rule 45 (binop -> GLOBID Equal exp .)
    RParen          reduce using rule 45 (binop -> GLOBID Equal exp .)
    COMMA           reduce using rule 45 (binop -> GLOBID Equal exp .)
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69

  ! Multiply        [ reduce using rule 45 (binop -> GLOBID Equal exp .) ]
  ! PLUS            [ reduce using rule 45 (binop -> GLOBID Equal exp .) ]
  ! Divide          [ reduce using rule 45 (binop -> GLOBID Equal exp .) ]
  ! Minus           [ reduce using rule 45 (binop -> GLOBID Equal exp .) ]
  ! Equality        [ reduce using rule 45 (binop -> GLOBID Equal exp .) ]
  ! Different       [ reduce using rule 45 (binop -> GLOBID Equal exp .) ]


state 96

    (29) Vector -> Array . LSquare RSquare
    (30) Vector -> Array . LSquare lit RSquare
    (31) Vector -> Array . LSquare GLOBID RSquare

    LSquare         shift and go to state 106


state 97

    (39) expWrapper -> LParen RParen .

    Semicolon       reduce using rule 39 (expWrapper -> LParen RParen .)
    Multiply        reduce using rule 39 (expWrapper -> LParen RParen .)
    PLUS            reduce using rule 39 (expWrapper -> LParen RParen .)
    Divide          reduce using rule 39 (expWrapper -> LParen RParen .)
    Minus           reduce using rule 39 (expWrapper -> LParen RParen .)
    Equality        reduce using rule 39 (expWrapper -> LParen RParen .)
    Different       reduce using rule 39 (expWrapper -> LParen RParen .)
    RParen          reduce using rule 39 (expWrapper -> LParen RParen .)
    COMMA           reduce using rule 39 (expWrapper -> LParen RParen .)


state 98

    (40) expWrapper -> LParen exps . RParen

    RParen          shift and go to state 107


state 99

    (32) exps -> exp .
    (33) exps -> exp . COMMA exps
    (41) binop -> exp . Multiply exp
    (42) binop -> exp . PLUS exp
    (43) binop -> exp . Divide exp
    (44) binop -> exp . Minus exp
    (46) binop -> exp . Equality exp
    (47) binop -> exp . Different exp

    RParen          reduce using rule 32 (exps -> exp .)
    COMMA           shift and go to state 108
    Multiply        shift and go to state 64
    PLUS            shift and go to state 65
    Divide          shift and go to state 66
    Minus           shift and go to state 67
    Equality        shift and go to state 68
    Different       shift and go to state 69


state 100

    (18) stmt -> vdecl Equal exp Semicolon .

    Return          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    While           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    If              reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Print           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Array           reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    GLOBID          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    LParen          reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    lit             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    int             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    void            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    ref             reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    noalias         reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    RBracket        reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)
    Else            reduce using rule 18 (stmt -> vdecl Equal exp Semicolon .)


state 101

    (20) stmt -> While LParen exp RParen . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare PLUS lit Semicolon
    (25) stmt -> . Array LSquare GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> . Array LSquare lit RSquare Minus lit Semicolon
    (27) stmt -> . Array LSquare GLOBID RSquare Minus lit Semicolon
    (28) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (50) vdecl -> . TYPE GLOBID
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    GLOBID          shift and go to state 52
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 109
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 102

    (21) stmt -> If LParen exp RParen . stmt
    (22) stmt -> If LParen exp RParen . stmt Else stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare PLUS lit Semicolon
    (25) stmt -> . Array LSquare GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> . Array LSquare lit RSquare Minus lit Semicolon
    (27) stmt -> . Array LSquare GLOBID RSquare Minus lit Semicolon
    (28) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (50) vdecl -> . TYPE GLOBID
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    GLOBID          shift and go to state 52
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 110
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 103

    (24) stmt -> Array LSquare lit RSquare . PLUS lit Semicolon
    (26) stmt -> Array LSquare lit RSquare . Minus lit Semicolon

    PLUS            shift and go to state 111
    Minus           shift and go to state 112


state 104

    (25) stmt -> Array LSquare GLOBID RSquare . PLUS lit Semicolon
    (27) stmt -> Array LSquare GLOBID RSquare . Minus lit Semicolon

    PLUS            shift and go to state 113
    Minus           shift and go to state 114


state 105

    (28) stmt -> GLOBID Equal Vector Semicolon .

    Return          reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    While           reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    If              reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    Print           reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    Array           reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    GLOBID          reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    LBracket        reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    LParen          reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    lit             reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    int             reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    void            reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    ref             reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    noalias         reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    RBracket        reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)
    Else            reduce using rule 28 (stmt -> GLOBID Equal Vector Semicolon .)


state 106

    (29) Vector -> Array LSquare . RSquare
    (30) Vector -> Array LSquare . lit RSquare
    (31) Vector -> Array LSquare . GLOBID RSquare

    RSquare         shift and go to state 115
    lit             shift and go to state 116
    GLOBID          shift and go to state 117


state 107

    (40) expWrapper -> LParen exps RParen .

    Semicolon       reduce using rule 40 (expWrapper -> LParen exps RParen .)
    Multiply        reduce using rule 40 (expWrapper -> LParen exps RParen .)
    PLUS            reduce using rule 40 (expWrapper -> LParen exps RParen .)
    Divide          reduce using rule 40 (expWrapper -> LParen exps RParen .)
    Minus           reduce using rule 40 (expWrapper -> LParen exps RParen .)
    Equality        reduce using rule 40 (expWrapper -> LParen exps RParen .)
    Different       reduce using rule 40 (expWrapper -> LParen exps RParen .)
    RParen          reduce using rule 40 (expWrapper -> LParen exps RParen .)
    COMMA           reduce using rule 40 (expWrapper -> LParen exps RParen .)


state 108

    (33) exps -> exp COMMA . exps
    (32) exps -> . exp
    (33) exps -> . exp COMMA exps
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    LParen          shift and go to state 47
    lit             shift and go to state 51
    GLOBID          shift and go to state 62

    exp                            shift and go to state 99
    exps                           shift and go to state 118
    binop                          shift and go to state 53

state 109

    (20) stmt -> While LParen exp RParen stmt .

    Return          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    While           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    If              reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Print           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Array           reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    GLOBID          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    LParen          reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    lit             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    int             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    void            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    ref             reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    noalias         reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    RBracket        reduce using rule 20 (stmt -> While LParen exp RParen stmt .)
    Else            reduce using rule 20 (stmt -> While LParen exp RParen stmt .)


state 110

    (21) stmt -> If LParen exp RParen stmt .
    (22) stmt -> If LParen exp RParen stmt . Else stmt

  ! shift/reduce conflict for Else resolved as shift
    Return          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    While           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    If              reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Print           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Array           reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    GLOBID          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    LParen          reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    lit             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    int             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    void            reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    ref             reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    noalias         reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    RBracket        reduce using rule 21 (stmt -> If LParen exp RParen stmt .)
    Else            shift and go to state 119

  ! Else            [ reduce using rule 21 (stmt -> If LParen exp RParen stmt .) ]


state 111

    (24) stmt -> Array LSquare lit RSquare PLUS . lit Semicolon

    lit             shift and go to state 120


state 112

    (26) stmt -> Array LSquare lit RSquare Minus . lit Semicolon

    lit             shift and go to state 121


state 113

    (25) stmt -> Array LSquare GLOBID RSquare PLUS . lit Semicolon

    lit             shift and go to state 122


state 114

    (27) stmt -> Array LSquare GLOBID RSquare Minus . lit Semicolon

    lit             shift and go to state 123


state 115

    (29) Vector -> Array LSquare RSquare .

    Semicolon       reduce using rule 29 (Vector -> Array LSquare RSquare .)


state 116

    (30) Vector -> Array LSquare lit . RSquare

    RSquare         shift and go to state 124


state 117

    (31) Vector -> Array LSquare GLOBID . RSquare

    RSquare         shift and go to state 125


state 118

    (33) exps -> exp COMMA exps .

    RParen          reduce using rule 33 (exps -> exp COMMA exps .)


state 119

    (22) stmt -> If LParen exp RParen stmt Else . stmt
    (15) stmt -> . blk
    (16) stmt -> . Return Semicolon
    (17) stmt -> . Return exp Semicolon
    (18) stmt -> . vdecl Equal exp Semicolon
    (19) stmt -> . exp Semicolon
    (20) stmt -> . While LParen exp RParen stmt
    (21) stmt -> . If LParen exp RParen stmt
    (22) stmt -> . If LParen exp RParen stmt Else stmt
    (23) stmt -> . Print exp Semicolon
    (24) stmt -> . Array LSquare lit RSquare PLUS lit Semicolon
    (25) stmt -> . Array LSquare GLOBID RSquare PLUS lit Semicolon
    (26) stmt -> . Array LSquare lit RSquare Minus lit Semicolon
    (27) stmt -> . Array LSquare GLOBID RSquare Minus lit Semicolon
    (28) stmt -> . GLOBID Equal Vector Semicolon
    (11) blk -> . LBracket stmts RBracket
    (12) blk -> . LBracket RBracket
    (50) vdecl -> . TYPE GLOBID
    (34) exp -> . LParen exp RParen
    (35) exp -> . lit
    (36) exp -> . binop
    (37) exp -> . GLOBID
    (38) exp -> . GLOBID expWrapper
    (53) TYPE -> . int
    (54) TYPE -> . void
    (55) TYPE -> . ref TYPE
    (56) TYPE -> . noalias ref TYPE
    (41) binop -> . exp Multiply exp
    (42) binop -> . exp PLUS exp
    (43) binop -> . exp Divide exp
    (44) binop -> . exp Minus exp
    (45) binop -> . GLOBID Equal exp
    (46) binop -> . exp Equality exp
    (47) binop -> . exp Different exp

    Return          shift and go to state 43
    While           shift and go to state 46
    If              shift and go to state 48
    Print           shift and go to state 49
    Array           shift and go to state 50
    GLOBID          shift and go to state 52
    LBracket        shift and go to state 33
    LParen          shift and go to state 47
    lit             shift and go to state 51
    int             shift and go to state 12
    void            shift and go to state 13
    ref             shift and go to state 14
    noalias         shift and go to state 15

    exp                            shift and go to state 44
    stmt                           shift and go to state 126
    blk                            shift and go to state 42
    vdecl                          shift and go to state 45
    TYPE                           shift and go to state 24
    binop                          shift and go to state 53

state 120

    (24) stmt -> Array LSquare lit RSquare PLUS lit . Semicolon

    Semicolon       shift and go to state 127


state 121

    (26) stmt -> Array LSquare lit RSquare Minus lit . Semicolon

    Semicolon       shift and go to state 128


state 122

    (25) stmt -> Array LSquare GLOBID RSquare PLUS lit . Semicolon

    Semicolon       shift and go to state 129


state 123

    (27) stmt -> Array LSquare GLOBID RSquare Minus lit . Semicolon

    Semicolon       shift and go to state 130


state 124

    (30) Vector -> Array LSquare lit RSquare .

    Semicolon       reduce using rule 30 (Vector -> Array LSquare lit RSquare .)


state 125

    (31) Vector -> Array LSquare GLOBID RSquare .

    Semicolon       reduce using rule 31 (Vector -> Array LSquare GLOBID RSquare .)


state 126

    (22) stmt -> If LParen exp RParen stmt Else stmt .

    Return          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    While           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    If              reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Print           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Array           reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    GLOBID          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    LParen          reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    lit             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    int             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    void            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    ref             reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    noalias         reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    RBracket        reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)
    Else            reduce using rule 22 (stmt -> If LParen exp RParen stmt Else stmt .)


state 127

    (24) stmt -> Array LSquare lit RSquare PLUS lit Semicolon .

    Return          reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    While           reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    If              reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    Print           reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    Array           reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    GLOBID          reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    LBracket        reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    LParen          reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    lit             reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    int             reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    void            reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    ref             reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    noalias         reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    RBracket        reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)
    Else            reduce using rule 24 (stmt -> Array LSquare lit RSquare PLUS lit Semicolon .)


state 128

    (26) stmt -> Array LSquare lit RSquare Minus lit Semicolon .

    Return          reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    While           reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    If              reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    Print           reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    Array           reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    GLOBID          reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    LBracket        reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    LParen          reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    lit             reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    int             reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    void            reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    ref             reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    noalias         reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    RBracket        reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)
    Else            reduce using rule 26 (stmt -> Array LSquare lit RSquare Minus lit Semicolon .)


state 129

    (25) stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .

    Return          reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    While           reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    If              reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    Print           reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    Array           reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    GLOBID          reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    LBracket        reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    LParen          reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    lit             reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    int             reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    void            reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    ref             reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    noalias         reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    RBracket        reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)
    Else            reduce using rule 25 (stmt -> Array LSquare GLOBID RSquare PLUS lit Semicolon .)


state 130

    (27) stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .

    Return          reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    While           reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    If              reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    Print           reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    Array           reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    GLOBID          reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    LBracket        reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    LParen          reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    lit             reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    int             reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    void            reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    ref             reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    noalias         reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    RBracket        reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)
    Else            reduce using rule 27 (stmt -> Array LSquare GLOBID RSquare Minus lit Semicolon .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for Else in state 110 resolved as shift
